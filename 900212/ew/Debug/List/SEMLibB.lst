##############################################################################
#                                                                            #
# IAR Atmel AVR C Compiler V3.10C/W32                  31/Jan/2006  09:32:43 #
# Copyright 1996-2004 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  M:\VisualState\ProjectM16Motor\ew\vsapi\SEMLibB.c       #
#    Command line =  --cpu=m16 -ms -o M:\VisualState\ProjectM16Motor\ew\Debu #
#                    g\Obj\ -lC M:\VisualState\ProjectM16Motor\ew\Debug\List #
#                    \ -lB M:\VisualState\ProjectM16Motor\ew\Debug\List\     #
#                    -z2 --no_cse --no_inline --no_code_motion               #
#                    --no_cross_call --no_clustering --debug                 #
#                    -DENABLE_BIT_DEFINITIONS -e -I                          #
#                    M:\VisualState\ProjectM16Motor\ew\src\ -I               #
#                    M:\VisualState\ProjectM16Motor\ew\vssrc\ -I             #
#                    M:\VisualState\ProjectM16Motor\ew\vsapi\ -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench        #
#                    3.2\avr\INC\" -I "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 3.2\avr\INC\CLIB\"           #
#                    --eeprom_size 512 M:\VisualState\ProjectM16Motor\ew\vsa #
#                    pi\SEMLibB.c                                            #
#    List file    =  M:\VisualState\ProjectM16Motor\ew\Debug\List\SEMLibB.ls #
#                    t                                                       #
#    Object file  =  M:\VisualState\ProjectM16Motor\ew\Debug\Obj\SEMLibB.r90 #
#                                                                            #
#                                                                            #
##############################################################################

M:\VisualState\ProjectM16Motor\ew\vsapi\SEMLibB.c
      1          /*
      2           * Type:        Source Code File
      3           *
      4           * Id:          SEMLibB.c
      5           *
      6           * Function:    Contains the functions for the SEM Library Basic version 4,
      7           *              which is described in SEMLibB.h.
      8           *
      9           * Portability: ANSI-C Compiler.
     10           *
     11           * Copyright (c) 1999 IAR Systems. All rights reserved.
     12           */
     13          
     14          /*
     15           * Version   ! Date   ! Status ! Changes
     16           *----------------------------------------------------------------------------
     17           * 4.0.0.13  ! 240299 ! Closed ! -
     18           * 4.0.4     ! 010799 ! Closed ! Minor update, there might be no changes to this particular file.
     19           */
     20          
     21          #include "SEMLibB.h"
     22          
     23          #if (SEM_SPEED)
     24          #define MODE_SEM_EVENT_ONLY     0x01
     25          #define MODE_SEM_EVENT          0x02
     26          #define MODE_SEM_STATE          0x03
     27          #endif
     28          
     29          #if (SEM_SIGNAL_DB)
     30          extern void SEM_SignalDB (SEM_EVENT_TYPE SignalNo);
     31          #endif
     32          
     33          #if (VS_REALLINKMODE == 1)
     34          #include "RealLink.h"
     35          VS_RLTASK VS_RL_TQ_DATA vsRLTask;
     36          #endif
     37          
     38          #ifdef VS_RUNTIME_INFO
     39          VSRunTimeInfo volatile const VS_RUNTIME_INFO_EXTKW vsRunTimeInfo = 
     40          {
     41            VS_SIGNATURE_VERSION,
     42            VS_SIGNATURE_CONTENT
     43          };
     44          #endif
     45          
     46          
     47          
     48          #if (SEM_SIGNAL)
     49          void SEM_InitSignalQueue (void)
     50          {
     51            SEM.SPut = 0;
     52            SEM.SGet = 0;
     53            SEM.SUsed = 0;
     54          }
     55          
     56          
     57          static unsigned char SEM_SignalQueuePut (SEM_EVENT_TYPE SignalNo)
     58          {
     59            if (SEM.SUsed == VS_SIGNAL_QUEUE_SIZE)
     60              return (SES_SIGNAL_QUEUE_FULL);
     61            SEM.SUsed++;
     62            SEM.SQueue[SEM.SPut] = SignalNo;
     63            if (++SEM.SPut == VS_SIGNAL_QUEUE_SIZE)
     64              SEM.SPut = 0;
     65            return (SES_OKAY);
     66          }
     67          
     68          
     69          static SEM_EVENT_TYPE SEM_SignalQueueGet (void)
     70          {
     71            SEM_EVENT_TYPE SignalNo;
     72          
     73            if (!SEM.SUsed)
     74              return (EVENT_UNDEFINED);
     75            SEM.SUsed--;
     76            SignalNo = SEM.SQueue[SEM.SGet];
     77            if (++SEM.SGet == VS_SIGNAL_QUEUE_SIZE)
     78              SEM.SGet = 0;
     79            return (SignalNo);
     80          }
     81          
     82          
     83          #if (SEM_SIGNAL_QUEUE_INFO == 1)
     84          void SEM_SignalQueueInfo (SEM_SIGNAL_QUEUE_TYPE *NofSignals)
     85          {
     86            *NofSignals = SEM.SUsed;
     87          }
     88          #endif
     89          #endif
     90          
     91          
     92          
     93          #if (SEM_INIT_ALL)

   \                                 In segment CODE, align 2, keep-with-next
     94          void SEM_InitAll (void)
   \                     SEM_InitAll:
     95          {
     96            SEM_Init();
   \   00000000   ....                       RCALL   SEM_Init
     97          #if (SEM_INIT_EXTERNAL_VARIABLES)
     98            SEM_InitExternalVariables();
     99          #endif
    100          #if (SEM_INIT_INTERNAL_VARIABLES)
    101            SEM_InitInternalVariables();
    102          #endif
    103          #if (SEM_SIGNAL)
    104            SEM_InitSignalQueue();
    105          #endif
    106          #if (VS_NOF_INSTANCES > 1)
    107            SEM_InitInstances();
    108          #if (VS_REALLINKMODE == 1)
    109            SEM_SetInstance(0);
    110          #endif
    111          #endif
    112          }
   \   00000002   9508                       RET
    113          #endif
    114          
    115          
    116          

   \                                 In segment CODE, align 2, keep-with-next
    117          void SEM_Init (void)
   \                     SEM_Init:
    118          {
    119          #ifdef VS_RUNTIME_INFO
    120            *vsRunTimeInfo.pSignatureVersion;
    121          #endif
    122          #if (VS_NOF_STATE_MACHINES != 0)
    123            for (SEM.i = 0; SEM.i < VS_NOF_STATE_MACHINES; SEM.i++)
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     (SEM + 12),R16
   \                     ??SEM_Init_0:
   \   00000006   9100....                   LDS     R16,(SEM + 12)
   \   0000000A   3004                       CPI     R16,4
   \   0000000C   F4C0                       BRCC    ??SEM_Init_1
    124            {
    125              SEM.WSV[SEM.i] = STATE_UNDEFINED;
   \   0000000E   EF2F                       LDI     R18,255
   \   00000010   ....                       LDI     R30,LOW(SEM)
   \   00000012   ....                       LDI     R31,(SEM) >> 8
   \   00000014   9100....                   LDS     R16,(SEM + 12)
   \   00000018   E010                       LDI     R17,0
   \   0000001A   0FE0                       ADD     R30,R16
   \   0000001C   1FF1                       ADC     R31,R17
   \   0000001E   8B24                       STD     Z+20,R18
    126          #if (VS_NOF_INSTANCES == 1)
    127              SEM.CSV[SEM.i] = STATE_UNDEFINED;
   \   00000020   EF2F                       LDI     R18,255
   \   00000022   ....                       LDI     R30,LOW(SEM)
   \   00000024   ....                       LDI     R31,(SEM) >> 8
   \   00000026   9100....                   LDS     R16,(SEM + 12)
   \   0000002A   E010                       LDI     R17,0
   \   0000002C   0FE0                       ADD     R30,R16
   \   0000002E   1FF1                       ADC     R31,R17
   \   00000030   8B20                       STD     Z+16,R18
    128          #endif
    129            }
   \   00000032   ....                       LDI     R30,LOW(SEM)
   \   00000034   ....                       LDI     R31,(SEM) >> 8
   \   00000036   8504                       LDD     R16,Z+12
   \   00000038   9503                       INC     R16
   \   0000003A   8704                       STD     Z+12,R16
   \   0000003C   CFE4                       RJMP    ??SEM_Init_0
    130          #if (SEM_NEXT_STATE_CHG == 1)
    131            SEM.Chg = 0;
    132          #endif
    133          #endif
    134            SEM.State = STATE_SEM_INITIALIZE;
   \                     ??SEM_Init_1:
   \   0000003E   E000                       LDI     R16,0
   \   00000040   9300....                   STS     (SEM + 1),R16
    135          #if (SEM_INQUIRY == 1)
    136            SEM.InqAct = VS_FALSE;
    137          #endif
    138          
    139          #if (VS_REALLINKMODE == 1)
    140            SEM.pTask = &vsRLTask;
    141          #endif
    142          }
   \   00000044   9508                       RET
    143          
    144          
    145          #if (VS_NOF_INSTANCES > 1)
    146          unsigned char SEM_InitInstances (void)
    147          {
    148          #if (VS_NOF_STATE_MACHINES != 0)
    149            for (SEM.i = 0; SEM.i < (VS_NOF_STATE_MACHINES * VS_NOF_INSTANCES); SEM.i++)
    150            {
    151              SEM.Ins[SEM.i] = STATE_UNDEFINED;
    152            }
    153          #endif
    154            SEM.CSV = SEM.Ins;
    155            SEM.ActIns = 0;
    156          
    157            return(SES_OKAY);
    158          }
    159          
    160          
    161          unsigned char SEM_SetInstance (SEM_INSTANCE_TYPE Instance)
    162          {
    163            if (Instance >= VS_NOF_INSTANCES)
    164              return (SES_RANGE_ERR);
    165            if ((SEM.State != STATE_SEM_INITIALIZE)
    166          #if (SEM_INQUIRY == 1)
    167                 || (SEM.InqAct)
    168          #endif
    169               )
    170              return (SES_ACTIVE);
    171          #if (VS_NOF_STATE_MACHINES != 0)
    172            SEM.CSV = (SEM.Ins + VS_NOF_STATE_MACHINES * Instance);
    173            SEM.ActIns = Instance;
    174          #endif
    175          #if (VS_REALLINKMODE == 1)
    176            VS_WAIT_ELM(VS_ENABLE_INSTANCE, Ind_INSTANCE_SET, &Instance);
    177          #endif
    178            return (SES_OKAY);
    179          }
    180          #endif
    181          
    182          
    183          #if (SEM_DEDUCT_FUNC == 0)

   \                                 In segment CODE, align 2, keep-with-next
    184          unsigned char SEM_Deduct (SEM_EVENT_TYPE EventNo)
   \                     SEM_Deduct:
    185          {
   \   00000000   2F10                       MOV     R17,R16
    186            if (VS_NOF_EVENTS <= EventNo)
   \   00000002   3119                       CPI     R17,25
   \   00000004   F010                       BRCS    ??SEM_Deduct_0
    187              return (SES_RANGE_ERR);
   \   00000006   E004                       LDI     R16,4
   \   00000008   9508                       RET
    188            SEM.EventNo = EventNo;
   \                     ??SEM_Deduct_0:
   \   0000000A   9310....                   STS     (SEM + 8),R17
    189            SEM.State = STATE_SEM_PREPARE;
   \   0000000E   E002                       LDI     R16,2
   \   00000010   9300....                   STS     (SEM + 1),R16
    190          #if (VS_NOF_EVENT_GROUPS != 0)
    191            SEM.DIt = 2;
    192          #endif
    193          #if (SEM_INQUIRY == 1)
    194            if (SEM.InqAct)
    195              return (SES_ACTIVE);
    196          #endif
    197          #if (VS_REALLINKMODE == 1)
    198            VS_WAIT_ELM(VS_ENABLE_EVENT, Ind_EVENT, &EventNo);
    199          #endif
    200            return (SES_OKAY);
   \   00000014   E000                       LDI     R16,0
   \   00000016   9508                       RET
    201          }
    202          #endif
    203          
    204          

   \                                 In segment CODE, align 2, keep-with-next
    205          unsigned char SEM_GetOutput (SEM_ACTION_EXPRESSION_TYPE *ActionNo)
   \                     SEM_GetOutput:
    206          {
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
   \   00000004   01D8                       MOVW    R27 : R26,R17 : R16
    207            for(;;)
    208            {
    209              switch (SEM.State)
   \                     ??SEM_GetOutput_0:
   \   00000006   9100....                   LDS     R16,(SEM + 1)
   \   0000000A   5002                       SUBI    R16,2
   \   0000000C   F049                       BREQ    ??SEM_GetOutput_1
   \   0000000E   950A                       DEC     R16
   \   00000010   F121                       BREQ    ??SEM_GetOutput_2
   \   00000012   950A                       DEC     R16
   \   00000014   F409                       BRNE    $+2+2
   \   00000016   C14F                       RJMP    ??SEM_GetOutput_3
   \   00000018   950A                       DEC     R16
   \   0000001A   F409                       BRNE    $+2+2
   \   0000001C   C169                       RJMP    ??SEM_GetOutput_4
   \   0000001E   C16A                       RJMP    ??SEM_GetOutput_5
    210              {
    211          #if (SEM_SIGNAL)
    212                case STATE_SEM_SIGNAL :
    213          Signal :
    214                  SEM.EventNo = SEM_SignalQueueGet ();
    215                  if (SEM.EventNo == EVENT_UNDEFINED)
    216                  {
    217                    SEM.State = STATE_SEM_OKAY;
    218                    return (SES_OKAY);
    219                  }
    220          #if (VS_NOF_STATE_MACHINES != 0)
    221                  for (SEM.i = 0; SEM.i < VS_NOF_STATE_MACHINES; SEM.i++)
    222                  {
    223                    if (SEM.WSV[SEM.i] != STATE_UNDEFINED)
    224                    {
    225          #if (SEM_NEXT_STATE_CHG == 1)
    226                      if (SEM.CSV[SEM.i] != SEM.WSV[SEM.i])
    227                        SEM.Chg = 1;
    228          #endif
    229                      SEM.CSV[SEM.i] = SEM.WSV[SEM.i];
    230                      SEM.WSV[SEM.i] = STATE_UNDEFINED;
    231                    }
    232                  }
    233          #endif
    234          #if (SEM_SIGNAL_DB)
    235                  SEM_SignalDB (SEM.EventNo);
    236          #endif
    237          #if (VS_REALLINKMODE == 1)
    238                  VS_WAIT_ELM(VS_ENABLE_SIGNAL, Ind_SIGNAL, &SEM.EventNo);
    239          #endif 
    240                  goto FirstRule;
    241          #endif
    242                case STATE_SEM_PREPARE :
    243          #if (SEM_SPEED)
    244                  SEM.Mode = MODE_SEM_EVENT_ONLY;
    245          #endif
    246          #if (VS_NOF_EVENT_GROUPS != 0)
    247          #if (SEM_EVENT_GROUP_INDEX)
    248                  if (SEM.DIt == 1)
    249                  {
    250                    SEM.EventNo = VS.EGI[SEM.EventNo];
    251                    if (SEM.EventNo == EVENT_GROUP_UNDEFINED)
    252                    {
    253          #if (SEM_SIGNAL)
    254                      SEM.DIt = 0;
    255                      goto Signal;
    256          #else
    257                      SEM.State = STATE_SEM_OKAY;
    258                      return (SES_OKAY);
    259          #endif
    260                    }
    261                    SEM.EventNo += VS_NOF_EVENTS;
    262                  }
    263                  else if (SEM.DIt == 0)
    264                  {
    265          #if (SEM_SIGNAL)
    266                    goto Signal;
    267          #else
    268                    SEM.State = STATE_SEM_OKAY;
    269                    return (SES_OKAY);
    270          #endif
    271                  }
    272                  SEM.DIt--;
    273          #endif
    274          #if (SEM_EVENT_GROUP_TABLE_INDEX)
    275                  if (SEM.DIt == 0)
    276                  {
    277                    if (++SEM.iFirstEgi >= SEM.iLastEgi)
    278                    {
    279          #if (SEM_SIGNAL)
    280                      goto Signal;
    281          #else
    282                      SEM.State = STATE_SEM_OKAY;
    283                      return (SES_OKAY);
    284          #endif
    285                    }
    286                    SEM.EventNo = VS.EGT[SEM.iFirstEgi];
    287                    SEM.EventNo += VS_NOF_EVENTS;
    288                  }
    289                  else if (SEM.DIt == 1)
    290                  {
    291                    SEM.iFirstEgi = VS.EGTI[SEM.EventNo];
    292                    SEM.iLastEgi = VS.EGTI[SEM.EventNo + 1];
    293                    if (SEM.iFirstEgi == SEM.iLastEgi)
    294                    {
    295          #if (SEM_SIGNAL)
    296                      SEM.DIt = 0;
    297                      goto Signal;
    298          #else
    299                      SEM.State = STATE_SEM_OKAY;
    300                      return (SES_OKAY);
    301          #endif
    302                    }
    303                    SEM.EventNo = VS.EGT[SEM.iFirstEgi];
    304                    SEM.EventNo += VS_NOF_EVENTS;
    305                    SEM.DIt--;
    306                  }
    307                  else if (SEM.DIt == 2)
    308                  {
    309                    SEM.DIt--;
    310                  }
    311          #endif
    312          #endif
    313          #if (SEM_SIGNAL)
    314          FirstRule :
    315          #endif
    316                  SEM.iFirstR = VS.RTI[SEM.EventNo];
   \                     ??SEM_GetOutput_1:
   \   00000020   ....                       LDI     R30,LOW(VS)
   \   00000022   ....                       LDI     R31,(VS) >> 8
   \   00000024   9100....                   LDS     R16,(SEM + 8)
   \   00000028   E010                       LDI     R17,0
   \   0000002A   0FE0                       ADD     R30,R16
   \   0000002C   1FF1                       ADC     R31,R17
   \   0000002E   5DE7                       SUBI    R30,215
   \   00000030   4FFE                       SBCI    R31,254
   \   00000032   8100                       LD      R16,Z
   \   00000034   9300....                   STS     (SEM + 10),R16
    317                  SEM.iLastR = VS.RTI[SEM.EventNo + 1];
   \   00000038   ....                       LDI     R30,LOW(VS)
   \   0000003A   ....                       LDI     R31,(VS) >> 8
   \   0000003C   9100....                   LDS     R16,(SEM + 8)
   \   00000040   E010                       LDI     R17,0
   \   00000042   5F0F                       SUBI    R16,255
   \   00000044   4F1F                       SBCI    R17,255
   \   00000046   0FE0                       ADD     R30,R16
   \   00000048   1FF1                       ADC     R31,R17
   \   0000004A   5DE7                       SUBI    R30,215
   \   0000004C   4FFE                       SBCI    R31,254
   \   0000004E   8100                       LD      R16,Z
   \   00000050   9300....                   STS     (SEM + 11),R16
    318                  SEM.State = STATE_SEM_CONSULT;
   \   00000054   E003                       LDI     R16,3
   \   00000056   9300....                   STS     (SEM + 1),R16
    319                case STATE_SEM_CONSULT :
    320                  while (SEM.iFirstR < SEM.iLastR)
   \                     ??SEM_GetOutput_2:
   \   0000005A   9100....                   LDS     R16,(SEM + 10)
   \   0000005E   9110....                   LDS     R17,(SEM + 11)
   \   00000062   1701                       CP      R16,R17
   \   00000064   F008                       BRCS    $+2+2
   \   00000066   C122                       RJMP    ??SEM_GetOutput_6
    321                  {
    322          #if (SEM_SPEED)
    323                    if (SEM.Mode == MODE_SEM_EVENT)
    324                    {
    325                      SEM.iRI = VS.RIS[SEM.iFirstR++];
    326                    }
    327                    else
    328                    {
    329                      if (SEM.Mode == MODE_SEM_EVENT_ONLY)
    330                      {
    331                        SEM.iRI = VS.RI[SEM.iFirstR++];
    332          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    333                        SEM.i = VS.RD[SEM.iRI];
    334                        SEM.iRI += 2;
    335                        SEM.nNxt = (unsigned char)(SEM.i & 0x0F);
    336                        SEM.nAction = (unsigned char)(SEM.i >> 4);
    337          #endif
    338          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_24_BIT)
    339                        SEM.iRI++;
    340                        SEM.nNxt = (unsigned char)(VS.RD[SEM.iRI++] >> 4);
    341                        SEM.i = VS.RD[SEM.iRI++];
    342                        SEM.nAction = (unsigned char)(SEM.i & 0x0F);
    343                        SEM.nSignal = (unsigned char)(SEM.i >> 4);
    344          #endif
    345          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    346                        SEM.nAction = (unsigned char)VS.RD[SEM.iRI++];
    347                        SEM.nNxt = (unsigned char)(VS.RD[SEM.iRI++];
    348                        SEM.iRI += 2;
    349          #endif
    350          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    351                        SEM.iRI += 2;
    352                        SEM.nNxt = (unsigned char)VS.RD[SEM.iRI];
    353                        SEM.iRI += 2;
    354                        SEM.nSignal = (unsigned char)VS.RD[SEM.iRI++];
    355                        SEM.nAction = (unsigned char)VS.RD[SEM.iRI++];
    356          #endif
    357          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    358                        SEM.i = VS.RD[SEM.iRI++];
    359                        SEM.nNxt = (unsigned char)((SEM.i >> 8) & 0x0F);
    360                        SEM.nAction = (unsigned char)(SEM.i >> 12);
    361          #endif
    362          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_32_BIT)
    363                        SEM.nNxt = (unsigned char)(VS.RD[SEM.iRI++] >> 12);
    364                        SEM.i = VS.RD[SEM.iRI++];
    365                        SEM.nAction = (unsigned char)(SEM.i & 0x0F);
    366                        SEM.nSignal = (unsigned char)((SEM.i >> 4) & 0x0F);
    367          #endif
    368          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    369                        SEM.i = VS.RD[SEM.iRI];
    370                        SEM.iRI += 2;
    371                        SEM.nNxt = (unsigned char)(SEM.i & 0x0FF);
    372                        SEM.nAction = (unsigned char)(SEM.i >> 8);
    373          #endif
    374          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    375                        SEM.iRI++;
    376                        SEM.nNxt = (unsigned char)(VS.RD[SEM.iRI++] >> 8);
    377                        SEM.i = VS.RD[SEM.iRI++];
    378                        SEM.nAction = (unsigned char)(SEM.i & 0x0FF);
    379                        SEM.nSignal = (unsigned char)(SEM.i >> 8);
    380          #endif
    381          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    382                        SEM.i = VS.RD[SEM.iRI++];
    383                        SEM.nNxt = (unsigned char)((SEM.i >> 16) & 0X0FF);
    384                        SEM.nAction = (unsigned char)(SEM.i >> 24);
    385          #endif
    386          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_64_BIT)
    387                        SEM.nNxt = (unsigned char)(VS.RD[SEM.iRI++] >> 24);
    388                        SEM.i = VS.RD[SEM.iRI++];
    389                        SEM.nAction = (unsigned char)(SEM.i & 0x0FF);
    390                        SEM.nSignal = (unsigned char)((SEM.i >> 8) & 0x0FF);
    391          #endif
    392                        goto ded_match_found;
    393                      }
    394                      else
    395                        SEM.iRI = VS.RIS[SEM.ruleq[SEM.iFirstR++]];
    396                    }
    397          #else
    398                    SEM.iRI = VS.RI[SEM.iFirstR++];
   \   00000068   ....                       LDI     R30,LOW(VS)
   \   0000006A   ....                       LDI     R31,(VS) >> 8
   \   0000006C   9100....                   LDS     R16,(SEM + 10)
   \   00000070   E010                       LDI     R17,0
   \   00000072   0FE0                       ADD     R30,R16
   \   00000074   1FF1                       ADC     R31,R17
   \   00000076   5FEA                       SUBI    R30,250
   \   00000078   4FFE                       SBCI    R31,254
   \   0000007A   8100                       LD      R16,Z
   \   0000007C   9300....                   STS     (SEM + 9),R16
   \   00000080   ....                       LDI     R30,LOW(SEM)
   \   00000082   ....                       LDI     R31,(SEM) >> 8
   \   00000084   8502                       LDD     R16,Z+10
   \   00000086   9503                       INC     R16
   \   00000088   8702                       STD     Z+10,R16
    399          #endif
    400          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    401                    SEM.i = VS.RD[SEM.iRI++];
    402                    SEM.nNxt = (unsigned char)(SEM.i & 0x0F);
    403                    SEM.nAction = (unsigned char)(SEM.i >> 4);
    404                    SEM.i = VS.RD[SEM.iRI++];
    405                    SEM.nPos = (unsigned char)(SEM.i & 0x0F);
    406          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    407                    SEM.nNeg = (unsigned char)(SEM.i >> 4);
    408          #endif
    409          #endif
    410          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_24_BIT)
    411                    SEM.i = VS.RD[SEM.iRI++];
   \   0000008A   ....                       LDI     R30,LOW(VS)
   \   0000008C   ....                       LDI     R31,(VS) >> 8
   \   0000008E   9100....                   LDS     R16,(SEM + 9)
   \   00000092   E010                       LDI     R17,0
   \   00000094   0FE0                       ADD     R30,R16
   \   00000096   1FF1                       ADC     R31,R17
   \   00000098   8504                       LDD     R16,Z+12
   \   0000009A   9300....                   STS     (SEM + 12),R16
   \   0000009E   ....                       LDI     R30,LOW(SEM)
   \   000000A0   ....                       LDI     R31,(SEM) >> 8
   \   000000A2   8501                       LDD     R16,Z+9
   \   000000A4   9503                       INC     R16
   \   000000A6   8701                       STD     Z+9,R16
    412                    SEM.nPos = (unsigned char)(SEM.i & 0x0F);
   \   000000A8   9100....                   LDS     R16,(SEM + 12)
   \   000000AC   700F                       ANDI    R16,0x0F
   \   000000AE   9300....                   STS     (SEM + 5),R16
    413          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    414                    SEM.nNeg = (unsigned char)(SEM.i >> 4);
    415          #endif
    416                    SEM.i = VS.RD[SEM.iRI++];
   \   000000B2   ....                       LDI     R30,LOW(VS)
   \   000000B4   ....                       LDI     R31,(VS) >> 8
   \   000000B6   9100....                   LDS     R16,(SEM + 9)
   \   000000BA   E010                       LDI     R17,0
   \   000000BC   0FE0                       ADD     R30,R16
   \   000000BE   1FF1                       ADC     R31,R17
   \   000000C0   8504                       LDD     R16,Z+12
   \   000000C2   9300....                   STS     (SEM + 12),R16
   \   000000C6   ....                       LDI     R30,LOW(SEM)
   \   000000C8   ....                       LDI     R31,(SEM) >> 8
   \   000000CA   8501                       LDD     R16,Z+9
   \   000000CC   9503                       INC     R16
   \   000000CE   8701                       STD     Z+9,R16
    417                    SEM.nGuard = (unsigned char)(SEM.i & 0x0F);
   \   000000D0   9100....                   LDS     R16,(SEM + 12)
   \   000000D4   700F                       ANDI    R16,0x0F
   \   000000D6   9300....                   STS     (SEM + 14),R16
    418                    SEM.nNxt = (unsigned char)(SEM.i >> 4);
   \   000000DA   9100....                   LDS     R16,(SEM + 12)
   \   000000DE   9502                       SWAP    R16
   \   000000E0   700F                       ANDI    R16,0x0F
   \   000000E2   9300....                   STS     (SEM + 6),R16
    419                    SEM.i = VS.RD[SEM.iRI++];
   \   000000E6   ....                       LDI     R30,LOW(VS)
   \   000000E8   ....                       LDI     R31,(VS) >> 8
   \   000000EA   9100....                   LDS     R16,(SEM + 9)
   \   000000EE   E010                       LDI     R17,0
   \   000000F0   0FE0                       ADD     R30,R16
   \   000000F2   1FF1                       ADC     R31,R17
   \   000000F4   8504                       LDD     R16,Z+12
   \   000000F6   9300....                   STS     (SEM + 12),R16
   \   000000FA   ....                       LDI     R30,LOW(SEM)
   \   000000FC   ....                       LDI     R31,(SEM) >> 8
   \   000000FE   8501                       LDD     R16,Z+9
   \   00000100   9503                       INC     R16
   \   00000102   8701                       STD     Z+9,R16
    420                    SEM.nAction = (unsigned char)(SEM.i & 0x0F);
   \   00000104   9100....                   LDS     R16,(SEM + 12)
   \   00000108   700F                       ANDI    R16,0x0F
   \   0000010A   9300....                   STS     (SEM + 7),R16
    421                    SEM.nSignal = (unsigned char)(SEM.i >> 4);
   \   0000010E   9100....                   LDS     R16,(SEM + 12)
   \   00000112   9502                       SWAP    R16
   \   00000114   700F                       ANDI    R16,0x0F
   \   00000116   9300....                   STS     (SEM + 15),R16
    422          #endif
    423          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    424                    SEM.nAction = (unsigned char)VS.RD[SEM.iRI++];
    425                    SEM.nNxt = (unsigned char)VS.RD[SEM.iRI++];
    426          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    427                    SEM.nNeg = (unsigned char)VS.RD[SEM.iRI++];
    428          #else
    429                    SEM.iRI++;
    430          #endif
    431                    SEM.nPos = (unsigned char)VS.RD[SEM.iRI++];
    432          #endif
    433          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    434          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    435                    SEM.nNeg = (unsigned char)VS.RD[SEM.iRI++];
    436          #else
    437                    SEM.iRI++;
    438          #endif
    439                    SEM.nPos = (unsigned char)VS.RD[SEM.iRI++];
    440                    SEM.nNxt = (unsigned char)VS.RD[SEM.iRI++];
    441                    SEM.nGuard = (unsigned char)VS.RD[SEM.iRI++];
    442                    SEM.nSignal = (unsigned char)VS.RD[SEM.iRI++];
    443                    SEM.nAction = (unsigned char)VS.RD[SEM.iRI++];
    444          #endif
    445          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    446                    SEM.i = VS.RD[SEM.iRI++];
    447                    SEM.nPos = (unsigned char)(SEM.i & 0x0F);
    448          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    449                    SEM.nNeg = (unsigned char)((SEM.i >> 4) & 0x0F);
    450          #endif
    451                    SEM.nNxt = (unsigned char)((SEM.i >> 8) & 0x0F);
    452                    SEM.nAction = (unsigned char)((SEM.i >> 12) & 0x0F);
    453          #endif
    454          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_32_BIT)
    455                    SEM.i = VS.RD[SEM.iRI++];
    456                    SEM.nPos = (unsigned char)(SEM.i & 0x0F);
    457          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    458                    SEM.nNeg = (unsigned char)((SEM.i >> 4) & 0x0F);
    459          #endif
    460                    SEM.nGuard = (unsigned char)((SEM.i >> 8) & 0x0F);
    461                    SEM.nNxt = (unsigned char)(SEM.i >> 12);
    462                    SEM.i = VS.RD[SEM.iRI++];
    463                    SEM.nAction = (unsigned char)(SEM.i & 0x0F);
    464                    SEM.nSignal = (unsigned char)((SEM.i >> 4) & 0x0F);
    465          #endif
    466          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    467                    SEM.i = VS.RD[SEM.iRI++];
    468                    SEM.nNxt = (unsigned char)(SEM.i & 0x0FF);
    469                    SEM.nAction = (unsigned char)(SEM.i >> 8);
    470                    SEM.i = VS.RD[SEM.iRI++];
    471                    SEM.nPos = (unsigned char)(SEM.i & 0x0FF);
    472          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    473                    SEM.nNeg = (unsigned char)(SEM.i >> 8);
    474          #endif
    475          #endif
    476          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    477                    SEM.i = VS.RD[SEM.iRI++];
    478                    SEM.nPos = (unsigned char)(SEM.i & 0x0FF);
    479          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    480                    SEM.nNeg = (unsigned char)(SEM.i >> 8);
    481          #endif
    482                    SEM.i = VS.RD[SEM.iRI++];
    483                    SEM.nGuard = (unsigned char)(SEM.i & 0x0FF);
    484                    SEM.nNxt = (unsigned char)(SEM.i >> 8);
    485                    SEM.i = VS.RD[SEM.iRI++];
    486                    SEM.nAction = (unsigned char)(SEM.i & 0x0FF);
    487                    SEM.nSignal = (unsigned char)(SEM.i >> 8);
    488          #endif
    489          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    490                    SEM.i = VS.RD[SEM.iRI++];
    491                    SEM.nPos = (unsigned char)(SEM.i & 0X0FF);
    492          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    493                    SEM.nNeg = (unsigned char)((SEM.i >> 8) & 0X0FF);
    494          #endif
    495                    SEM.nNxt = (unsigned char)((SEM.i >> 16) & 0x0FF);
    496                    SEM.nAction = (unsigned char)((SEM.i >> 24) & 0x0FF);
    497          #endif
    498          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_64_BIT)
    499                    SEM.i = VS.RD[SEM.iRI++];
    500                    SEM.nPos = (unsigned char)(SEM.i & 0x0FF);
    501          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    502                    SEM.nNeg = (unsigned char)((SEM.i >> 8) & 0x0FF);
    503          #endif
    504                    SEM.nGuard = (unsigned char)((SEM.i >> 16) & 0x0FF);
    505                    SEM.nNxt = (unsigned char)(SEM.i >> 24);
    506                    SEM.i = VS.RD[SEM.iRI++];
    507                    SEM.nAction = (unsigned char)(SEM.i & 0x0FF);
    508                    SEM.nSignal = (unsigned char)((SEM.i >> 8) & 0x0FF);
    509          #endif
    510          #if (VS_NOF_STATE_MACHINES != 0)
    511                    for (SEM.nNo = 0 ; SEM.nNo < SEM.nPos; SEM.nNo++)
   \   0000011A   E000                       LDI     R16,0
   \   0000011C   9300....                   STS     (SEM + 3),R16
   \                     ??SEM_GetOutput_7:
   \   00000120   9100....                   LDS     R16,(SEM + 3)
   \   00000124   9110....                   LDS     R17,(SEM + 5)
   \   00000128   1701                       CP      R16,R17
   \   0000012A   F540                       BRCC    ??SEM_GetOutput_8
    512                    {
    513                      SEM.sa = (SEM_STATE_TYPE) VS.RD[SEM.iRI++];
   \   0000012C   ....                       LDI     R30,LOW(VS)
   \   0000012E   ....                       LDI     R31,(VS) >> 8
   \   00000130   9100....                   LDS     R16,(SEM + 9)
   \   00000134   E010                       LDI     R17,0
   \   00000136   0FE0                       ADD     R30,R16
   \   00000138   1FF1                       ADC     R31,R17
   \   0000013A   8504                       LDD     R16,Z+12
   \   0000013C   9300....                   STS     (SEM + 13),R16
   \   00000140   ....                       LDI     R30,LOW(SEM)
   \   00000142   ....                       LDI     R31,(SEM) >> 8
   \   00000144   8501                       LDD     R16,Z+9
   \   00000146   9503                       INC     R16
   \   00000148   8701                       STD     Z+9,R16
    514                      if (SEM.sa != SEM.CSV[VS.SMI[SEM.sa]])
   \   0000014A   9140....                   LDS     R20,(SEM + 13)
   \   0000014E   ....                       LDI     R16,LOW(SEM)
   \   00000150   ....                       LDI     R17,(SEM) >> 8
   \   00000152   9120....                   LDS     R18,(SEM + 13)
   \   00000156   E030                       LDI     R19,0
   \   00000158   01F9                       MOVW    R31 : R30,R19 : R18
   \   0000015A   ....                       SUBI    R30,LOW((-(VS) & 0xFFFF))
   \   0000015C   ....                       SBCI    R31,(-(VS) & 0xFFFF) >> 8
   \   0000015E   8120                       LD      R18,Z
   \   00000160   E030                       LDI     R19,0
   \   00000162   0F02                       ADD     R16,R18
   \   00000164   1F13                       ADC     R17,R19
   \   00000166   01F8                       MOVW    R31 : R30,R17 : R16
   \   00000168   8900                       LDD     R16,Z+16
   \   0000016A   1740                       CP      R20,R16
   \   0000016C   F009                       BREQ    $+2+2
   \   0000016E   CF75                       RJMP    ??SEM_GetOutput_2
    515                        goto NextRule;
    516                    }
   \   00000170   ....                       LDI     R30,LOW(SEM)
   \   00000172   ....                       LDI     R31,(SEM) >> 8
   \   00000174   8103                       LDD     R16,Z+3
   \   00000176   9503                       INC     R16
   \   00000178   8303                       STD     Z+3,R16
   \   0000017A   CFD2                       RJMP    ??SEM_GetOutput_7
    517          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    518                    for (SEM.nNo = 0; SEM.nNo < SEM.nNeg; SEM.nNo++)
    519                    {
    520                      SEM.i = VS.RD[SEM.iRI++];
    521                      SEM.sa = SEM.CSV[VS.SMI[SEM.i]];
    522                      if ((SEM.sa == STATE_UNDEFINED) || (SEM.sa == (SEM_STATE_TYPE) SEM.i))
    523                        goto NextRule;
    524                    }
    525          #endif
    526          #endif
    527          #if ((SEM_RDHW_TYPE_2 || SEM_RDHW_TYPE_3) && (SEM_GUARD_EXPRESSION))
    528                    if (SEM.nGuard)
   \                     ??SEM_GetOutput_8:
   \   0000017C   9100....                   LDS     R16,(SEM + 14)
   \   00000180   2300                       TST     R16
   \   00000182   F141                       BREQ    ??SEM_GetOutput_9
    529                    {
    530                      for (SEM.nNo = 0; SEM.nNo < SEM.nGuard; SEM.nNo++)
   \   00000184   E000                       LDI     R16,0
   \   00000186   9300....                   STS     (SEM + 3),R16
   \                     ??SEM_GetOutput_10:
   \   0000018A   9100....                   LDS     R16,(SEM + 3)
   \   0000018E   9110....                   LDS     R17,(SEM + 14)
   \   00000192   1701                       CP      R16,R17
   \   00000194   F4F8                       BRCC    ??SEM_GetOutput_9
    531                      {
    532          #if (SEM_FUNCEXPHANDLING == 0)
    533                        if ((*VSGuard[VS.RD[SEM.iRI++]])() == VS_FALSE)              
   \   00000196   9100....                   LDS     R16,(SEM + 9)
   \   0000019A   2F10                       MOV     R17,R16
   \   0000019C   9513                       INC     R17
   \   0000019E   9310....                   STS     (SEM + 9),R17
   \   000001A2   ....                       LDI     R30,LOW(VS)
   \   000001A4   ....                       LDI     R31,(VS) >> 8
   \   000001A6   E010                       LDI     R17,0
   \   000001A8   0FE0                       ADD     R30,R16
   \   000001AA   1FF1                       ADC     R31,R17
   \   000001AC   8504                       LDD     R16,Z+12
   \   000001AE   E010                       LDI     R17,0
   \   000001B0   0F00                       LSL     R16
   \   000001B2   1F11                       ROL     R17
   \   000001B4   01F8                       MOVW    R31 : R30,R17 : R16
   \   000001B6   ....                       SUBI    R30,LOW((-(VSGuard) & 0xFFFF))
   \   000001B8   ....                       SBCI    R31,(-(VSGuard) & 0xFFFF) >> 8
   \   000001BA   8100                       LD      R16,Z
   \   000001BC   8111                       LDD     R17,Z+1
   \   000001BE   01F8                       MOVW    R31 : R30,R17 : R16
   \   000001C0   9509                       ICALL
   \   000001C2   2300                       TST     R16
   \   000001C4   F409                       BRNE    $+2+2
   \   000001C6   CF49                       RJMP    ??SEM_GetOutput_2
    534          #else
    535                          if (VSGuard(VS.RD[SEM.iRI++]) == VS_FALSE)              
    536          #endif
    537                          goto NextRule;
    538                      }
   \   000001C8   ....                       LDI     R30,LOW(SEM)
   \   000001CA   ....                       LDI     R31,(SEM) >> 8
   \   000001CC   8103                       LDD     R16,Z+3
   \   000001CE   9503                       INC     R16
   \   000001D0   8303                       STD     Z+3,R16
   \   000001D2   CFDB                       RJMP    ??SEM_GetOutput_10
    539                    }
    540          #endif
    541          
    542          #if (VS_REALLINKMODE == 1)
    543                    {
    544                    SEM_RULE_TABLE_INDEX_TYPE ri = SEM.iFirstR - 1;
    545                    VS_WAIT_ELM(VS_ENABLE_TRANS, Ind_TRANS, &ri);
    546                    }
    547          #endif
    548          
    549          #if (SEM_SPEED)
    550          ded_match_found:
    551          #endif
    552          #if (VS_NOF_STATE_MACHINES != 0)
    553                    for (SEM.nNo = 0; SEM.nNo < SEM.nNxt; SEM.nNo++)
   \                     ??SEM_GetOutput_9:
   \   000001D4   E000                       LDI     R16,0
   \   000001D6   9300....                   STS     (SEM + 3),R16
   \                     ??SEM_GetOutput_11:
   \   000001DA   9100....                   LDS     R16,(SEM + 3)
   \   000001DE   9110....                   LDS     R17,(SEM + 6)
   \   000001E2   1701                       CP      R16,R17
   \   000001E4   F008                       BRCS    $+2+2
   \   000001E6   C041                       RJMP    ??SEM_GetOutput_12
    554                    {
    555                      SEM.sa = (SEM_STATE_TYPE) VS.RD[SEM.iRI++];
   \   000001E8   ....                       LDI     R30,LOW(VS)
   \   000001EA   ....                       LDI     R31,(VS) >> 8
   \   000001EC   9100....                   LDS     R16,(SEM + 9)
   \   000001F0   E010                       LDI     R17,0
   \   000001F2   0FE0                       ADD     R30,R16
   \   000001F4   1FF1                       ADC     R31,R17
   \   000001F6   8504                       LDD     R16,Z+12
   \   000001F8   9300....                   STS     (SEM + 13),R16
   \   000001FC   ....                       LDI     R30,LOW(SEM)
   \   000001FE   ....                       LDI     R31,(SEM) >> 8
   \   00000200   8501                       LDD     R16,Z+9
   \   00000202   9503                       INC     R16
   \   00000204   8701                       STD     Z+9,R16
    556                      SEM.i = VS.SMI[SEM.sa];
   \   00000206   9100....                   LDS     R16,(SEM + 13)
   \   0000020A   E010                       LDI     R17,0
   \   0000020C   01F8                       MOVW    R31 : R30,R17 : R16
   \   0000020E   ....                       SUBI    R30,LOW((-(VS) & 0xFFFF))
   \   00000210   ....                       SBCI    R31,(-(VS) & 0xFFFF) >> 8
   \   00000212   8100                       LD      R16,Z
   \   00000214   9300....                   STS     (SEM + 12),R16
    557                      if (SEM.WSV[SEM.i] == STATE_UNDEFINED)
   \   00000218   ....                       LDI     R30,LOW(SEM)
   \   0000021A   ....                       LDI     R31,(SEM) >> 8
   \   0000021C   9100....                   LDS     R16,(SEM + 12)
   \   00000220   E010                       LDI     R17,0
   \   00000222   0FE0                       ADD     R30,R16
   \   00000224   1FF1                       ADC     R31,R17
   \   00000226   8904                       LDD     R16,Z+20
   \   00000228   3F0F                       CPI     R16,255
   \   0000022A   F459                       BRNE    ??SEM_GetOutput_13
    558                        SEM.WSV[SEM.i] = SEM.sa;
   \   0000022C   9120....                   LDS     R18,(SEM + 13)
   \   00000230   ....                       LDI     R30,LOW(SEM)
   \   00000232   ....                       LDI     R31,(SEM) >> 8
   \   00000234   9100....                   LDS     R16,(SEM + 12)
   \   00000238   E010                       LDI     R17,0
   \   0000023A   0FE0                       ADD     R30,R16
   \   0000023C   1FF1                       ADC     R31,R17
   \   0000023E   8B24                       STD     Z+20,R18
   \   00000240   C00E                       RJMP    ??SEM_GetOutput_14
    559                      else if (SEM.WSV[SEM.i] != SEM.sa)
   \                     ??SEM_GetOutput_13:
   \   00000242   ....                       LDI     R30,LOW(SEM)
   \   00000244   ....                       LDI     R31,(SEM) >> 8
   \   00000246   9100....                   LDS     R16,(SEM + 12)
   \   0000024A   E010                       LDI     R17,0
   \   0000024C   0FE0                       ADD     R30,R16
   \   0000024E   1FF1                       ADC     R31,R17
   \   00000250   8904                       LDD     R16,Z+20
   \   00000252   9110....                   LDS     R17,(SEM + 13)
   \   00000256   1701                       CP      R16,R17
   \   00000258   F011                       BREQ    ??SEM_GetOutput_14
    560                        return (SES_CONTRADICTION);
   \   0000025A   E003                       LDI     R16,3
   \   0000025C   C04C                       RJMP    ??SEM_GetOutput_15
    561                    }
   \                     ??SEM_GetOutput_14:
   \   0000025E   ....                       LDI     R30,LOW(SEM)
   \   00000260   ....                       LDI     R31,(SEM) >> 8
   \   00000262   8103                       LDD     R16,Z+3
   \   00000264   9503                       INC     R16
   \   00000266   8303                       STD     Z+3,R16
   \   00000268   CFB8                       RJMP    ??SEM_GetOutput_11
    562          #endif
    563          #if (SEM_SIGNAL)
    564                    if (SEM.nSignal)
    565                    {
    566                      for (SEM.nNo = 0; SEM.nNo < SEM.nSignal; SEM.nNo++)
    567                      {
    568                        SEM.i = VS.RD[SEM.iRI++];
    569          #if (SEM_SIGNAL_QUEUE_ERROR_IF_FULL)
    570                        if (SEM_SignalQueuePut ((SEM_EVENT_TYPE)SEM.i) == SES_SIGNAL_QUEUE_FULL)
    571                          return (SES_SIGNAL_QUEUE_FULL);
    572          #endif
    573          #if (SEM_SIGNAL_QUEUE_NO_ERROR_IF_FULL)
    574                        SEM_SignalQueuePut ((SEM_EVENT_TYPE)SEM.i);
    575          #endif
    576                      }
    577                    }
    578          #endif
    579                    if (SEM.nAction)
   \                     ??SEM_GetOutput_12:
   \   0000026A   9100....                   LDS     R16,(SEM + 7)
   \   0000026E   2300                       TST     R16
   \   00000270   F409                       BRNE    $+2+2
   \   00000272   CEF3                       RJMP    ??SEM_GetOutput_2
    580                    {
    581                      *ActionNo = (SEM_ACTION_EXPRESSION_TYPE)VS.RD[SEM.iRI];
   \   00000274   ....                       LDI     R30,LOW(VS)
   \   00000276   ....                       LDI     R31,(VS) >> 8
   \   00000278   9100....                   LDS     R16,(SEM + 9)
   \   0000027C   E010                       LDI     R17,0
   \   0000027E   0FE0                       ADD     R30,R16
   \   00000280   1FF1                       ADC     R31,R17
   \   00000282   8504                       LDD     R16,Z+12
   \   00000284   930C                       ST      X,R16
    582                      if (SEM.nAction > 1)
   \   00000286   9100....                   LDS     R16,(SEM + 7)
   \   0000028A   3002                       CPI     R16,2
   \   0000028C   F068                       BRCS    ??SEM_GetOutput_16
    583                      {
    584                        SEM.iRI++;
   \   0000028E   ....                       LDI     R30,LOW(SEM)
   \   00000290   ....                       LDI     R31,(SEM) >> 8
   \   00000292   8501                       LDD     R16,Z+9
   \   00000294   9503                       INC     R16
   \   00000296   8701                       STD     Z+9,R16
    585                        SEM.nAction--;
   \   00000298   ....                       LDI     R30,LOW(SEM)
   \   0000029A   ....                       LDI     R31,(SEM) >> 8
   \   0000029C   8107                       LDD     R16,Z+7
   \   0000029E   950A                       DEC     R16
   \   000002A0   8307                       STD     Z+7,R16
    586                        SEM.State = STATE_SEM_OUTPUT;
   \   000002A2   E004                       LDI     R16,4
   \   000002A4   9300....                   STS     (SEM + 1),R16
    587                      }
    588          #if (VS_REALLINKMODE == 1)
    589                      VS_WAIT_ELM(VS_ENABLE_ACTION, Ind_ACTION, ActionNo);
    590          #endif
    591                      return (SES_FOUND);
   \                     ??SEM_GetOutput_16:
   \   000002A8   E001                       LDI     R16,1
   \   000002AA   C025                       RJMP    ??SEM_GetOutput_15
    592                    }
    593          NextRule :
    594                    ;
    595                  }
    596          #if (SEM_SPEED)
    597                  if (SEM.Mode == MODE_SEM_EVENT_ONLY)
    598                  {
    599                    SEM.iFirstR = VS.RTIS[SEM.EventNo];
    600                    SEM.iLastR = VS.RTIS[SEM.EventNo + 1];
    601                    if ((SEM.iLastR - SEM.iFirstR) > ((SE_MAXQUEUE + 1) / 2))
    602                    {
    603                      SEM.iLastR = 0;
    604                      SEM.fm_i = VS.sti[SEM.EventNo];
    605                      SEM.lm_i = VS.sti[SEM.EventNo + 1];
    606                      while (SEM.fm_i < SEM.lm_i)
    607                      {
    608                        SEM.sa = SEM.CSV[VS.smn[SEM.fm_i]];
    609                        SEM.fs_i = VS.sri[SEM.sa];
    610                        SEM.ls_i = VS.sri[SEM.sa + 1];
    611                        while (SEM.fs_i < SEM.ls_i)
    612                        {
    613                          if (VS.sit[SEM.fs_i] == SEM.EventNo)
    614                          {
    615                            SEM.qe = VS.srt[SEM.fs_i];
    616                            if (VS.cmc[SEM.qe] > 1)
    617                            {
    618                              for (SEM.iFirstR = 0; SEM.iFirstR < SEM.iLastR; SEM.iFirstR++)
    619                              {
    620                                if (SEM.ruleq[SEM.iFirstR] == SEM.qe)
    621                                  break;
    622                              }
    623                              if (SEM.iFirstR == SEM.iLastR)
    624                                SEM.ruleq [SEM.iLastR++] = SEM.qe;
    625                            }
    626                            else
    627                              SEM.ruleq [SEM.iLastR++] = SEM.qe;
    628                          }
    629                          SEM.fs_i++;
    630                        }
    631                        SEM.fm_i++;
    632                      }
    633                      SEM.iFirstR = 0;
    634                      SEM.Mode = MODE_SEM_STATE;
    635                    }
    636                    else
    637                      SEM.Mode = MODE_SEM_EVENT;
    638                    break;
    639                  }
    640                  else
    641          #endif
    642          #if (VS_NOF_EVENT_GROUPS != 0)
    643                  {
    644                    SEM.State = STATE_SEM_PREPARE;
    645                    break;
    646                  }
    647          #else
    648                  {
    649          #if (SEM_SIGNAL)
    650                    goto Signal;
    651          #else
    652                    SEM.State = STATE_SEM_OKAY;
   \                     ??SEM_GetOutput_6:
   \   000002AC   E005                       LDI     R16,5
   \   000002AE   9300....                   STS     (SEM + 1),R16
    653                    return (SES_OKAY);
   \   000002B2   E000                       LDI     R16,0
   \   000002B4   C020                       RJMP    ??SEM_GetOutput_15
    654          #endif
    655                  }
    656          #endif
    657                case STATE_SEM_OUTPUT :
    658                  if (SEM.nAction)
   \                     ??SEM_GetOutput_3:
   \   000002B6   9100....                   LDS     R16,(SEM + 7)
   \   000002BA   2300                       TST     R16
   \   000002BC   F0A9                       BREQ    ??SEM_GetOutput_17
    659                  {
    660                    *ActionNo = (SEM_ACTION_EXPRESSION_TYPE) VS.RD[SEM.iRI++];
   \   000002BE   ....                       LDI     R30,LOW(VS)
   \   000002C0   ....                       LDI     R31,(VS) >> 8
   \   000002C2   9100....                   LDS     R16,(SEM + 9)
   \   000002C6   E010                       LDI     R17,0
   \   000002C8   0FE0                       ADD     R30,R16
   \   000002CA   1FF1                       ADC     R31,R17
   \   000002CC   8504                       LDD     R16,Z+12
   \   000002CE   930C                       ST      X,R16
   \   000002D0   ....                       LDI     R30,LOW(SEM)
   \   000002D2   ....                       LDI     R31,(SEM) >> 8
   \   000002D4   8501                       LDD     R16,Z+9
   \   000002D6   9503                       INC     R16
   \   000002D8   8701                       STD     Z+9,R16
    661                    SEM.nAction--;
   \   000002DA   ....                       LDI     R30,LOW(SEM)
   \   000002DC   ....                       LDI     R31,(SEM) >> 8
   \   000002DE   8107                       LDD     R16,Z+7
   \   000002E0   950A                       DEC     R16
   \   000002E2   8307                       STD     Z+7,R16
    662          #if (VS_REALLINKMODE == 1)
    663                      VS_WAIT_ELM(VS_ENABLE_ACTION, Ind_ACTION, ActionNo);
    664          #endif
    665                    return (SES_FOUND);
   \   000002E4   E001                       LDI     R16,1
   \   000002E6   C007                       RJMP    ??SEM_GetOutput_15
    666                  }
    667                  SEM.State = STATE_SEM_CONSULT;
   \                     ??SEM_GetOutput_17:
   \   000002E8   E003                       LDI     R16,3
   \   000002EA   9300....                   STS     (SEM + 1),R16
   \   000002EE   CE8B                       RJMP    ??SEM_GetOutput_0
    668                  break;
    669                case STATE_SEM_OKAY :
    670                  return (SES_OKAY);
   \                     ??SEM_GetOutput_4:
   \   000002F0   E000                       LDI     R16,0
   \   000002F2   C001                       RJMP    ??SEM_GetOutput_15
    671                default :
    672                  return (SES_EMPTY);
   \                     ??SEM_GetOutput_5:
   \   000002F4   E007                       LDI     R16,7
   \                     ??SEM_GetOutput_15:
   \   000002F6   91A9                       LD      R26,Y+
   \   000002F8   91B9                       LD      R27,Y+
   \   000002FA   9508                       RET
    673              }
    674            }
    675          }
    676          
    677          
    678          #if (SEM_GET_OUTPUT_ALL == 1)
    679          #if (SEM_SIGNAL)
    680          #error SEM_GetOutputAll cannot be used when the Project contains signals.
    681          #endif
    682          unsigned char SEM_GetOutputAll (SEM_ACTION_EXPRESSION_TYPE *ActionVector,
    683            SEM_ACTION_EXPRESSION_TYPE MaxSize)
    684          {
    685            SEM_ACTION_EXPRESSION_TYPE i;
    686            unsigned char CC;
    687          
    688            for (i = 0; ((CC = SEM_GetOutput(&ActionVector[i])) == SES_FOUND) && i < MaxSize - 1; i++);
    689          
    690            if (CC == SES_OKAY)
    691            {
    692              ActionVector[i] = ACTION_EXPRESSION_TERMINATION_ID;
    693              return (SES_OKAY);
    694            }
    695            if (CC == SES_FOUND)
    696              return (SES_BUFFER_OVERFLOW);
    697            return (CC);
    698          }
    699          #endif
    700          
    701          
    702          #if (SEM_NEXT_STATE_CHG == 1)
    703          unsigned char SEM_NextStateChg (void)
    704          #else

   \                                 In segment CODE, align 2, keep-with-next
    705          unsigned char SEM_NextState (void)
   \                     SEM_NextState:
    706          #endif
    707          {
   \   00000000   938A                       ST      -Y,R24
   \   00000002   9721                       SBIW    R29 : R28,1
    708            unsigned char CC;
    709            SEM_ACTION_EXPRESSION_TYPE nAction;
    710          
    711            if (SEM.State != STATE_SEM_OKAY)
   \   00000004   9100....                   LDS     R16,(SEM + 1)
   \   00000008   3005                       CPI     R16,5
   \   0000000A   F049                       BREQ    ??SEM_NextState_0
    712            {
    713              while ((CC = SEM_GetOutput (&nAction)) == SES_FOUND);
   \                     ??SEM_NextState_1:
   \   0000000C   018E                       MOVW    R17 : R16,R29 : R28
   \   0000000E   ....                       RCALL   SEM_GetOutput
   \   00000010   2F80                       MOV     R24,R16
   \   00000012   3081                       CPI     R24,1
   \   00000014   F3D9                       BREQ    ??SEM_NextState_1
    714              if (CC != SES_OKAY)
   \   00000016   2388                       TST     R24
   \   00000018   F011                       BREQ    ??SEM_NextState_0
    715                return(CC);
   \   0000001A   2F08                       MOV     R16,R24
   \   0000001C   C034                       RJMP    ??SEM_NextState_2
    716            }
    717          #if (VS_NOF_STATE_MACHINES != 0)
    718            for (SEM.i = 0; SEM.i < VS_NOF_STATE_MACHINES; SEM.i++)
   \                     ??SEM_NextState_0:
   \   0000001E   E000                       LDI     R16,0
   \   00000020   9300....                   STS     (SEM + 12),R16
   \                     ??SEM_NextState_3:
   \   00000024   9100....                   LDS     R16,(SEM + 12)
   \   00000028   3004                       CPI     R16,4
   \   0000002A   F548                       BRCC    ??SEM_NextState_4
    719            {
    720              if (SEM.WSV[SEM.i] != STATE_UNDEFINED)
   \   0000002C   ....                       LDI     R30,LOW(SEM)
   \   0000002E   ....                       LDI     R31,(SEM) >> 8
   \   00000030   9100....                   LDS     R16,(SEM + 12)
   \   00000034   E010                       LDI     R17,0
   \   00000036   0FE0                       ADD     R30,R16
   \   00000038   1FF1                       ADC     R31,R17
   \   0000003A   8904                       LDD     R16,Z+20
   \   0000003C   3F0F                       CPI     R16,255
   \   0000003E   F0C9                       BREQ    ??SEM_NextState_5
    721              {
    722          #if (SEM_NEXT_STATE_CHG == 1)
    723                if (SEM.CSV[SEM.i] != SEM.WSV[SEM.i])
    724                  SEM.Chg = 1;
    725          #endif
    726                SEM.CSV[SEM.i] = SEM.WSV[SEM.i];
   \   00000040   ....                       LDI     R30,LOW(SEM)
   \   00000042   ....                       LDI     R31,(SEM) >> 8
   \   00000044   9100....                   LDS     R16,(SEM + 12)
   \   00000048   E010                       LDI     R17,0
   \   0000004A   0FE0                       ADD     R30,R16
   \   0000004C   1FF1                       ADC     R31,R17
   \   0000004E   8924                       LDD     R18,Z+20
   \   00000050   ....                       LDI     R30,LOW(SEM)
   \   00000052   ....                       LDI     R31,(SEM) >> 8
   \   00000054   9100....                   LDS     R16,(SEM + 12)
   \   00000058   E010                       LDI     R17,0
   \   0000005A   0FE0                       ADD     R30,R16
   \   0000005C   1FF1                       ADC     R31,R17
   \   0000005E   8B20                       STD     Z+16,R18
    727                SEM.WSV[SEM.i] = STATE_UNDEFINED;
   \   00000060   EF2F                       LDI     R18,255
   \   00000062   ....                       LDI     R30,LOW(SEM)
   \   00000064   ....                       LDI     R31,(SEM) >> 8
   \   00000066   9100....                   LDS     R16,(SEM + 12)
   \   0000006A   E010                       LDI     R17,0
   \   0000006C   0FE0                       ADD     R30,R16
   \   0000006E   1FF1                       ADC     R31,R17
   \   00000070   8B24                       STD     Z+20,R18
    728              }
    729            }
   \                     ??SEM_NextState_5:
   \   00000072   ....                       LDI     R30,LOW(SEM)
   \   00000074   ....                       LDI     R31,(SEM) >> 8
   \   00000076   8504                       LDD     R16,Z+12
   \   00000078   9503                       INC     R16
   \   0000007A   8704                       STD     Z+12,R16
   \   0000007C   CFD3                       RJMP    ??SEM_NextState_3
    730          #endif
    731            SEM.State = STATE_SEM_INITIALIZE;
   \                     ??SEM_NextState_4:
   \   0000007E   E000                       LDI     R16,0
   \   00000080   9300....                   STS     (SEM + 1),R16
    732          
    733          #if (SEM_NEXT_STATE_CHG == 1)
    734            if (SEM.Chg)
    735            {
    736              SEM.Chg = 0;
    737              return (SES_FOUND);
    738            }
    739            return (SES_OKAY);
    740          #else
    741            return (SES_OKAY);
   \   00000084   E000                       LDI     R16,0
   \                     ??SEM_NextState_2:
   \   00000086   9621                       ADIW    R29 : R28,1
   \   00000088   9189                       LD      R24,Y+
   \   0000008A   9508                       RET
    742          #endif
    743          }
    744          
    745          
    746          #if (SEM_INQUIRY == 1)
    747          unsigned char SEM_Inquiry(void)
    748          {
    749            SEM.InqAct = VS_FALSE;
    750            if (SEM.State != STATE_SEM_INITIALIZE)
    751              return (SES_ACTIVE);
    752            return (SES_OKAY);
    753          }
    754          
    755          
    756          unsigned char SEM_GetInput (SEM_EVENT_TYPE *EventNo,
    757            SEM_EVENT_TYPE *EventList)
    758          {
    759            if (!SEM.InqAct)
    760              SEM.InqEventNo = 0;
    761            for(;;)
    762            {
    763              SEM.InqAct = VS_FALSE;
    764              if (SEM.InqEventNo >= VS_NOF_EVENTS)
    765                break;
    766              if (EventList != NULL)
    767              {
    768                SEM.InqFoundEventNo = EventList[SEM.InqEventNo];
    769                if (SEM.InqFoundEventNo == EVENT_TERMINATION_ID)
    770                  break;
    771                if (VS_NOF_EVENTS <= SEM.InqFoundEventNo)
    772                  return (SES_RANGE_ERR);
    773              }
    774              else
    775                SEM.InqFoundEventNo = SEM.InqEventNo;
    776              SEM.InqEventNo++;
    777              SEM.InqCurrentEventNo = SEM.InqFoundEventNo;
    778              for (SEM.IIt = 2; SEM.IIt; SEM.IIt--)
    779              {
    780          #if (VS_NOF_EVENT_GROUPS > 0)
    781          #if (SEM_EVENT_GROUP_TABLE_INDEX)
    782                if (SEM.IIt == 2)
    783                {
    784                  SEM.iInqFirstEgi = VS.EGTI[SEM.InqCurrentEventNo];
    785                  SEM.iInqLastEgi = VS.EGTI[SEM.InqCurrentEventNo + 1];
    786                }
    787          #endif
    788          #endif
    789                if (SEM.IIt == 1)
    790                {
    791          #if (VS_NOF_EVENT_GROUPS > 0)
    792          #if (SEM_EVENT_GROUP_INDEX)
    793                  SEM.InqCurrentEventNo = VS.EGI[SEM.InqCurrentEventNo];
    794                  if (SEM.InqCurrentEventNo == EVENT_GROUP_UNDEFINED)
    795                    break;
    796                  SEM.InqCurrentEventNo += VS_NOF_EVENTS;
    797          #endif
    798          #if (SEM_EVENT_GROUP_TABLE_INDEX)
    799                  if (SEM.iInqFirstEgi == SEM.iInqLastEgi)
    800                    break;
    801                  SEM.InqCurrentEventNo = VS.EGT[SEM.iInqFirstEgi++];
    802                  SEM.InqCurrentEventNo += VS_NOF_EVENTS;
    803                  SEM.IIt++;
    804          #endif
    805          #else
    806                  break;
    807          #endif
    808                }
    809                SEM.iInqFirstR = VS.RTI[SEM.InqCurrentEventNo];
    810                SEM.iInqLastR = VS.RTI[SEM.InqCurrentEventNo + 1];
    811          #if (SEM_SPEED)
    812                if (SEM.iInqFirstR >= SEM.iInqLastR)
    813                {
    814                  SEM.iInqFirstR = VS.RTIS[SEM.InqCurrentEventNo];
    815                  SEM.iInqLastR = VS.RTIS[SEM.InqCurrentEventNo+1];
    816                }
    817                else
    818                {
    819                  SEM.InqAct = VS_TRUE;
    820                  *EventNo = SEM.InqFoundEventNo;
    821                  return (SES_FOUND);
    822                }
    823          #endif
    824                while (SEM.iInqFirstR < SEM.iInqLastR)
    825                {
    826          #if (SEM_SPEED)
    827                  SEM.iInqRI = VS.RIS[SEM.iInqFirstR++];
    828          #else
    829                  SEM.iInqRI = VS.RI[SEM.iInqFirstR++];
    830          #endif
    831          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    832                 	SEM.iInqRI++;
    833           		    SEM.j = VS.RD[SEM.iInqRI++];
    834                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0F);
    835          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    836                  SEM.nInqNeg = (unsigned char)(SEM.j >> 4);
    837          #endif
    838          #endif
    839          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_24_BIT)
    840           		    SEM.j = VS.RD[SEM.iInqRI];
    841                  SEM.iInqRI += 3;
    842                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0F);
    843          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    844                  SEM.nInqNeg = (unsigned char)(SEM.j >> 4);
    845          #endif
    846          #endif
    847          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    848                  SEM.iInqRI += 2;
    849          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    850                  SEM.nInqNeg = (unsigned char)VS.RD[SEM.iInqRI++];
    851          #else
    852                  SEM.iInqRI++;
    853          #endif
    854                  SEM.nInqPos = (unsigned char)VS.RD[SEM.iInqRI++];
    855          #endif
    856          #if (SEM_RD_WIDTH_8_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    857          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    858                  SEM.nInqNeg = (unsigned char)VS.RD[SEM.iInqRI++];
    859          #else
    860                  SEM.iInqRI++;
    861          #endif
    862                  SEM.nInqPos = (unsigned char)VS.RD[SEM.iInqRI];
    863                  SEM.iInqRI += 5;
    864          #endif
    865          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_16_BIT)
    866           		    SEM.j = VS.RD[SEM.iInqRI++];
    867                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0F);
    868          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    869                  SEM.nInqNeg = (unsigned char)((SEM.j >> 4) & 0x0F);
    870          #endif
    871          #endif
    872          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_32_BIT)
    873                  SEM.j = VS.RD[SEM.iInqRI];
    874                  SEM.iInqRI += 2;
    875                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0F);
    876          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    877                  SEM.nInqNeg = (unsigned char)((SEM.j >> 4) & 0x0F);
    878          #endif
    879          #endif
    880          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    881                  SEM.iInqRI++;
    882                  SEM.j = VS.RD[SEM.iInqRI++];
    883                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0FF);
    884          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    885                  SEM.nInqNeg = (unsigned char)(SEM.j >> 8);
    886          #endif
    887          #endif
    888          #if (SEM_RD_WIDTH_16_BIT && SEM_RDHW_TYPE_2 && SEM_RDHW_WIDTH_48_BIT)
    889           		    SEM.j = VS.RD[SEM.iInqRI];
    890                  SEM.iInqRI += 3;
    891                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0FF);
    892          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    893                  SEM.nInqNeg = (unsigned char)(SEM.j >> 8);
    894          #endif
    895          #endif
    896          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_1 && SEM_RDHW_WIDTH_32_BIT)
    897           		    SEM.j = VS.RD[SEM.iInqRI++];
    898                  SEM.nInqPos = (unsigned char)(SEM.j & 0X0FF);
    899          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    900                  SEM.nInqNeg = (unsigned char)((SEM.j >> 8) & 0X0FF);
    901          #endif
    902          #endif
    903          #if (SEM_RD_WIDTH_32_BIT && SEM_RDHW_TYPE_3 && SEM_RDHW_WIDTH_64_BIT)
    904                  SEM.j = VS.RD[SEM.iInqRI++];
    905                  SEM.nInqPos = (unsigned char)(SEM.j & 0x0FF);
    906          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    907                  SEM.nInqNeg = (unsigned char)((SEM.j >> 8) & 0x0FF);
    908          #endif
    909                  SEM.iInqRI++;
    910          #endif
    911          #if (VS_NOF_STATE_MACHINES != 0)
    912                  for (SEM.nInqNo = 0; SEM.nInqNo < SEM.nInqPos; SEM.nInqNo++)
    913                  {
    914                    SEM.sb = (SEM_STATE_TYPE) VS.RD[SEM.iInqRI++];
    915                    if (SEM.sb != SEM.CSV[VS.SMI[SEM.sb]])
    916                      goto NextRuleInq;
    917                  }
    918          #if (SEM_RMN_NEGATIVE_STATE_SYNCS)
    919                  for (SEM.nInqNo = 0; SEM.nInqNo < SEM.nInqNeg; SEM.nInqNo++)
    920                  {
    921                    SEM.j = VS.RD[SEM.iInqRI++];
    922                    SEM.sb = SEM.CSV[VS.SMI[SEM.j]];
    923                    if ((SEM.sb == STATE_UNDEFINED) || (SEM.sb == (SEM_STATE_TYPE) SEM.j))
    924                      goto NextRuleInq;
    925                  }
    926          #endif
    927          #endif
    928                  SEM.InqAct = VS_TRUE;
    929                  *EventNo = SEM.InqFoundEventNo;
    930                  return (SES_FOUND);
    931          NextRuleInq:
    932                  ;
    933                }
    934              }
    935            }
    936            return (SES_OKAY);
    937          }
    938          
    939          
    940          #if (SEM_GET_INPUT_ALL == 1)
    941          unsigned char SEM_GetInputAll (SEM_EVENT_TYPE *EventVector,
    942            SEM_EVENT_TYPE *EventList, SEM_EVENT_TYPE MaxSize)
    943          {
    944            SEM_EVENT_TYPE  i;
    945            unsigned char CC;
    946          
    947            for (i = 0; ((CC = SEM_GetInput (&EventVector[i], EventList)) == SES_FOUND)
    948                  && i < MaxSize - 1; i++);
    949            if (CC == SES_OKAY)
    950            {
    951              EventVector[i] = EVENT_TERMINATION_ID;
    952              return (SES_OKAY);
    953            }
    954            if (CC == SES_FOUND)
    955              return (SES_BUFFER_OVERFLOW);
    956            return (CC);
    957          }
    958          #endif
    959          #endif
    960          
    961          
    962          #if (SEM_NAME == 1)
    963          unsigned char SEM_Name (unsigned char IdentType, 
    964            SEM_EXPLANATION_TYPE IdentNo, char *Text, unsigned short MaxSize)
    965          {
    966            char  c, *s;
    967            unsigned short i;
    968          
    969            if (!MaxSize)
    970              return (SES_TEXT_TOO_LONG);
    971            switch (IdentType)
    972            {
    973          #if (VS_EVENT_NAMES != 0)
    974              case EVENT_TYPE :
    975                if (VS_NOF_EVENTS <= IdentNo)
    976                  return (SES_RANGE_ERR);
    977                s = (char *)VS.ENames + VS.ENI[IdentNo];
    978                break;
    979          #endif
    980          #if ((VS_STATE_NAMES != 0) && (VS_NOF_STATES != 0))
    981              case STATE_TYPE :
    982                if (VS_NOF_STATES <= IdentNo)
    983                  return (SES_RANGE_ERR);
    984                s = (char *)VS.SNames + VS.SNI[IdentNo];
    985                break;
    986          #endif
    987          #if ((VS_ACTION_FUNCTION_NAMES != 0) && (VS_NOF_ACTION_FUNCTIONS != 0))
    988              case ACTION_TYPE :
    989                if (VS_NOF_ACTION_FUNCTIONS <= IdentNo)
    990                  return (SES_RANGE_ERR);
    991                s = (char *)VS.ANames + VS.ANI[IdentNo];
    992                break;
    993          #endif
    994              default :
    995                return (SES_TYPE_ERR);
    996            }
    997            for (i = 0; i < MaxSize; i++)
    998            {
    999              c = *s++;
   1000              *Text++ = c;
   1001              if (c == '\0')
   1002                return (SES_OKAY);
   1003            }
   1004            Text--;
   1005            *Text = '\0';
   1006            return (SES_TEXT_TOO_LONG);
   1007          }
   1008          #endif
   1009          
   1010          
   1011          #if (SEM_NAME_ABS == 1)
   1012          unsigned char SEM_NameAbs (unsigned char IdentType, 
   1013            SEM_EXPLANATION_TYPE IdentNo, char VS_TQ_RULEBASE **Text)
   1014          {
   1015            switch (IdentType)
   1016            {
   1017          #if (VS_EVENT_NAMES != 0)
   1018              case EVENT_TYPE :
   1019                if (VS_NOF_EVENTS <= IdentNo)
   1020                  return (SES_RANGE_ERR);
   1021                *Text = (char const *)&VS.ENames + VS.ENI[IdentNo];
   1022                break;
   1023          #endif
   1024          #if ((VS_STATE_NAMES != 0) && (VS_NOF_STATES != 0))
   1025              case STATE_TYPE :
   1026                if (VS_NOF_STATES <= IdentNo)
   1027                  return (SES_RANGE_ERR);
   1028                *Text = (char const *)&VS.SNames + VS.SNI[IdentNo];
   1029                break;
   1030          #endif
   1031          #if ((VS_ACTION_FUNCTION_NAMES != 0) && (VS_NOF_ACTION_FUNCTIONS != 0))
   1032              case ACTION_TYPE :
   1033                if (VS_NOF_ACTION_FUNCTIONS <= IdentNo)
   1034                  return (SES_RANGE_ERR);
   1035                *Text = (char const *)&VS.ANames + VS.ANI[IdentNo];
   1036                break;
   1037          #endif
   1038              default :
   1039                return (SES_TYPE_ERR);
   1040            }
   1041            return (SES_OKAY);
   1042          }
   1043          #endif
   1044          
   1045          
   1046          #if (SEM_EXPL == 1)
   1047          unsigned char SEM_Expl (unsigned char IdentType, SEM_EXPLANATION_TYPE IdentNo,
   1048            char *Text, unsigned short MaxSize)
   1049          {
   1050            char  c, *s;
   1051            unsigned short i;
   1052          
   1053            if (!MaxSize)
   1054              return (SES_TEXT_TOO_LONG);
   1055            switch (IdentType)
   1056            {
   1057          #if (VS_EVENT_EXPLS != 0)
   1058              case EVENT_TYPE :
   1059                if (VS_NOF_EVENTS <= IdentNo)
   1060                  return (SES_RANGE_ERR);
   1061                s = (char *)VS.EExpls + VS.EEI[IdentNo];
   1062                break;
   1063          #endif
   1064          #if ((VS_STATE_EXPLS != 0) && (VS_NOF_STATES != 0))
   1065              case STATE_TYPE :
   1066                if (VS_NOF_STATES <= IdentNo)
   1067                  return (SES_RANGE_ERR);
   1068                s = (char *)VS.SExpls + VS.SEI[IdentNo];
   1069                break;
   1070          #endif
   1071          #if ((VS_ACTION_EXPLS != 0) && (VS_NOF_ACTION_FUNCTIONS != 0))
   1072              case ACTION_TYPE :
   1073                if (VS_NOF_ACTION_FUNCTIONS <= IdentNo)
   1074                  return (SES_RANGE_ERR);
   1075                s = (char *)VS.AExpls + VS.AEI[IdentNo];
   1076                break;
   1077          #endif
   1078              default :
   1079                return (SES_TYPE_ERR);
   1080            }
   1081          
   1082            for (i = 0; i < MaxSize; i++)
   1083            {
   1084              c = *s++;
   1085              *Text++ = c;
   1086              if (c == '\0')
   1087                return (SES_OKAY);
   1088            }
   1089            Text--;
   1090            *Text = '\0';
   1091            return (SES_TEXT_TOO_LONG);
   1092          }
   1093          #endif
   1094          
   1095          
   1096          #if (SEM_EXPL_ABS == 1)
   1097          unsigned char SEM_ExplAbs (unsigned char IdentType,
   1098            SEM_EXPLANATION_TYPE IdentNo, char VS_TQ_RULEBASE **Text)
   1099          {
   1100            switch (IdentType)
   1101            {
   1102          #if (VS_EVENT_EXPLS != 0)
   1103              case EVENT_TYPE :
   1104                if (VS_NOF_EVENTS <= IdentNo)
   1105                  return (SES_RANGE_ERR);
   1106                *Text = (char const *)&VS.EExpls + VS.EEI[IdentNo];
   1107                break;
   1108          #endif
   1109          #if ((VS_STATE_EXPLS != 0) && (VS_NOF_STATES != 0))
   1110              case STATE_TYPE :
   1111                if (VS_NOF_STATES <= IdentNo)
   1112                  return (SES_RANGE_ERR);
   1113                *Text = (char const *)&VS.SExpls + VS.SEI[IdentNo];
   1114                break;
   1115          #endif
   1116          #if ((VS_ACTION_EXPLS != 0) && (VS_NOF_ACTION_FUNCTIONS != 0))
   1117              case ACTION_TYPE :
   1118                if (VS_NOF_ACTION_FUNCTIONS <= IdentNo)
   1119                  return (SES_RANGE_ERR);
   1120                *Text = (char const *)&VS.AExpls + VS.AEI[IdentNo];
   1121                break;
   1122          #endif
   1123              default :
   1124                return (SES_TYPE_ERR);
   1125            }
   1126            return (SES_OKAY);
   1127          }
   1128          #endif
   1129          
   1130          
   1131          #if (SEM_STATE == 1)
   1132          unsigned char SEM_State (SEM_STATE_MACHINE_TYPE StateMachineNo,
   1133            SEM_STATE_TYPE *StateNo)
   1134          {
   1135            if (VS_NOF_STATE_MACHINES <= StateMachineNo)
   1136              return (SES_RANGE_ERR);
   1137          #if (VS_NOF_STATE_MACHINES != 0)
   1138            *StateNo = SEM.CSV[StateMachineNo];
   1139          #else
   1140            *StateNo = 0;
   1141          #endif
   1142            return (SES_FOUND);
   1143          }
   1144          #endif
   1145          
   1146          
   1147          #if (SEM_STATE_ALL == 1)
   1148          unsigned char SEM_StateAll (SEM_STATE_TYPE *StateVector,
   1149            SEM_STATE_MACHINE_TYPE MaxSize)
   1150          {
   1151            SEM_STATE_MACHINE_TYPE i;
   1152          
   1153            if (VS_NOF_STATE_MACHINES > MaxSize)
   1154              return (SES_BUFFER_OVERFLOW);
   1155          
   1156          #if (VS_NOF_STATE_MACHINES != 0)
   1157            for (i = 0; i < VS_NOF_STATE_MACHINES; i++)
   1158              StateVector[i] = SEM.CSV[i];
   1159          #else
   1160            for (i = 0; i < VS_NOF_STATE_MACHINES; i++)
   1161              StateVector[i] = 0;
   1162          #endif
   1163            return (SES_FOUND);
   1164          }
   1165          #endif
   1166          
   1167          
   1168          #if (SEM_MACHINE == 1)
   1169          unsigned char SEM_Machine (SEM_STATE_TYPE StateNo,
   1170            SEM_STATE_MACHINE_TYPE *StateMachineNo)
   1171          {
   1172            if (VS_NOF_STATES <= StateNo)
   1173              return (SES_RANGE_ERR);
   1174          #if (VS_NOF_STATE_MACHINES != 0)
   1175            *StateMachineNo = VS.SMI[StateNo];
   1176          #else
   1177            *StateMachineNo = 0;
   1178          #endif
   1179            return (SES_FOUND);
   1180          }
   1181          #endif
   1182          
   1183          
   1184          #if (SEM_FORCE_STATE == 1)
   1185          unsigned char SEM_ForceState (SEM_STATE_TYPE StateNo)
   1186          {
   1187            if (VS_NOF_STATES <= StateNo)
   1188              return (SES_RANGE_ERR);
   1189          #if (VS_NOF_STATE_MACHINES != 0)
   1190            SEM.CSV[VS.SMI[StateNo]] = StateNo;
   1191          #endif
   1192            return (SES_OKAY);
   1193          }
   1194          #endif

   Maximum stack usage in bytes:

     Function             CSTACK RSTACK
     --------             ------ ------
     SEM_Deduct               0      2
     SEM_GetOutput            2      2
       ->   Indirect call     2      2
     SEM_Init                 0      2
     SEM_InitAll              0      2
       -> SEM_Init            0      2
     SEM_NextState            2      2
       -> SEM_GetOutput       2      2


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     SEM_InitAll       4
     SEM_Init         70
     SEM_Deduct       24
     SEM_GetOutput   764
     SEM_NextState   140

 
 1 002 bytes in segment CODE
 
 1 002 bytes of CODE memory

Errors: none
Warnings: none
