##############################################################################
#                                                                            #
# IAR Atmel AVR C Compiler V3.10C/W32                  31/Jan/2006  09:33:11 #
# Copyright 1996-2004 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  M:\VisualState\ProjectM16Motor\ew\src\usart2.c          #
#    Command line =  --cpu=m16 -ms -o M:\VisualState\ProjectM16Motor\ew\Debu #
#                    g\Obj\ -lC M:\VisualState\ProjectM16Motor\ew\Debug\List #
#                    \ -lB M:\VisualState\ProjectM16Motor\ew\Debug\List\     #
#                    -z2 --no_cse --no_inline --no_code_motion               #
#                    --no_cross_call --no_clustering --debug                 #
#                    -DENABLE_BIT_DEFINITIONS -e -I                          #
#                    M:\VisualState\ProjectM16Motor\ew\src\ -I               #
#                    M:\VisualState\ProjectM16Motor\ew\vssrc\ -I             #
#                    M:\VisualState\ProjectM16Motor\ew\vsapi\ -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench        #
#                    3.2\avr\INC\" -I "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 3.2\avr\INC\CLIB\"           #
#                    --eeprom_size 512 M:\VisualState\ProjectM16Motor\ew\src #
#                    \usart2.c                                               #
#    List file    =  M:\VisualState\ProjectM16Motor\ew\Debug\List\usart2.lst #
#    Object file  =  M:\VisualState\ProjectM16Motor\ew\Debug\Obj\usart2.r90  #
#                                                                            #
#                                                                            #
##############################################################################

M:\VisualState\ProjectM16Motor\ew\src\usart2.c
      1          // AVR306: Using the AVR UART in C
      2          // Routines for interrupt controlled USART
      3          
      4          #include <iom16.h>			// Atmel definitions Mega16
      5          #include <inavr.h>			// Atmel register definitions
      6          #include "VSMain.h"			// Visual State definitions
      7          
      8          #include "defs.h"			// Application (GENERAL) defs

  };
   ^
"M:\VisualState\ProjectM16Motor\ew\src\defs.h",122  Warning[Pe375]: 
          declaration requires a typedef name

  };
   ^
"M:\VisualState\ProjectM16Motor\ew\src\defs.h",131  Warning[Pe375]: 
          declaration requires a typedef name

  };
   ^
"M:\VisualState\ProjectM16Motor\ew\src\defs.h",137  Warning[Pe375]: 
          declaration requires a typedef name
      9          #include "globals.h"		// Application global data/variables
     10          
     11          #include "usart2.h"			// Function declarations for this file
     12          
     13          void vss_seq_error( void);
     14          void wal_eetbl_write( unsigned char s_address, unsigned char s_value);
     15          unsigned char wal_bsf_eeget( unsigned char s_address);
     16          void wal_motor_start( void);
     17          void wal_motor_stop( void);
     18          unsigned char wal_pos_similar( void);
     19          

   \                                 In segment CODE, align 2, keep-with-next
     20          void USART_Init_High( unsigned int baudrate )
   \                     USART_Init_High:
     21          {
     22          // Initialize USART High speed comms 9 bit 2 stop
     23          
     24          	/* Set the baud rate */
     25          	UBRRH = (unsigned char) (baudrate>>8);                    
   \   00000000   0198                       MOVW    R19 : R18,R17 : R16
   \   00000002   2F23                       MOV     R18,R19
   \   00000004   BD20                       OUT     0x20,R18
     26          	UBRRL = (unsigned char) baudrate;
   \   00000006   2F20                       MOV     R18,R16
   \   00000008   B929                       OUT     0x09,R18
     27          	
     28          	/* Enable UART RX interupt and enable RX and TX and 9 bit data */
     29          	//UCSRB = ( ( 1 << RXCIE ) | ( 1 << RXEN ) | ( 1 << TXEN ) | ( 1 << UCSZ2 ) ); 
     30          	UCSRB = 0xDC; 
   \   0000000A   ED2C                       LDI     R18,220
   \   0000000C   B92A                       OUT     0x0A,R18
     31          
     32          	// Hi-speed frame format: 9 data 2stop no parity
     33          	// For devices with Extended IO 
     34          	// UCSRC == 0x86 or 0x8E if 2 stop bits
     35          	UCSRC = 0x8E;              
   \   0000000E   E82E                       LDI     R18,142
   \   00000010   BD20                       OUT     0x20,R18
     36          }
   \   00000012   9508                       RET
     37          

   \                                 In segment CODE, align 2, keep-with-next
     38          void USART_Init_Low( unsigned int baudrate )
   \                     USART_Init_Low:
     39          {
     40          // Initialize USART low speed comms 8bit
     41          
     42          	/* Set the baud rate */
     43          	UBRRH = (unsigned char) (baudrate>>8);                  
   \   00000000   0198                       MOVW    R19 : R18,R17 : R16
   \   00000002   2F23                       MOV     R18,R19
   \   00000004   BD20                       OUT     0x20,R18
     44          	UBRRL = (unsigned char) baudrate;
   \   00000006   2F20                       MOV     R18,R16
   \   00000008   B929                       OUT     0x09,R18
     45          	
     46          	/* Enable UART RX interupt and enable RX and TX and 9 bit data */
     47          	UCSRB = ( ( 1 << RXCIE ) | ( 1 << RXEN ) | ( 1 << TXEN ) | (1 << TXCIE) ); 
   \   0000000A   ED28                       LDI     R18,216
   \   0000000C   B92A                       OUT     0x0A,R18
     48          
     49          	// Lo-speed frame format: 8 data 1stop ( UCSRC defaults OK)
     50          	// UCSRC = (1<<UCSZ1)|(1<<UCSZ0);
     51          }
   \   0000000E   9508                       RET
     52          

   \                                 In segment CODE, align 2, keep-with-next
     53          void wal_start_tx( void)
   \                     wal_start_tx:
     54          {
     55          // disable rx interrupt & setup TX_En 
     56              
     57              UCSRB &= ~(1<<RXCIE);			// disable rx interrupt
   \   00000000   9857                       CBI     0x0A,0x07
     58              PORTB = (PINB | 0x10);  		// Switch line driver on
   \   00000002   B306                       IN      R16,0x16
   \   00000004   6100                       ORI     R16,0x10
   \   00000006   BB08                       OUT     0x18,R16
     59          	// ? set address bit ?
     60              uc_comm_flag |= WAL_COMM_SMSG;	// Transmission in progress
   \   00000008   ....                       LDI     R30,LOW(uc_comm_flag)
   \   0000000A   ....                       LDI     R31,(uc_comm_flag) >> 8
   \   0000000C   8100                       LD      R16,Z
   \   0000000E   6008                       ORI     R16,0x08
   \   00000010   8300                       ST      Z,R16
     61          
     62          	// if hi-speed then set 9bit (= start of message)
     63          	if( uc_comm_hilo == 0)
   \   00000012   9100....                   LDS     R16,uc_comm_hilo
   \   00000016   2300                       TST     R16
   \   00000018   F409                       BRNE    ??wal_start_tx_0
     64          	{
     65              	UCSRB |= (1<<TXB8);
   \   0000001A   9A50                       SBI     0x0A,0x00
     66          	}
     67          }
   \                     ??wal_start_tx_0:
   \   0000001C   9508                       RET
     68              
     69          

   \                                 In segment CODE, align 2, keep-with-next
     70          void wal_end_tx(void)
   \                     wal_end_tx:
     71          {
     72            PORTB = (PINB & ~0x10);			// Switch off line driver
   \   00000000   B306                       IN      R16,0x16
   \   00000002   7E0F                       ANDI    R16,0xEF
   \   00000004   BB08                       OUT     0x18,R16
     73            UCSRB |= (1<<RXCIE);    		// enable RX interrupt
   \   00000006   9A57                       SBI     0x0A,0x07
     74            
     75            uc_comm_flag &= ~WAL_COMM_SMSG;	// Flag data sent (msgtx complete)
   \   00000008   ....                       LDI     R30,LOW(uc_comm_flag)
   \   0000000A   ....                       LDI     R31,(uc_comm_flag) >> 8
   \   0000000C   8100                       LD      R16,Z
   \   0000000E   7F07                       ANDI    R16,0xF7
   \   00000010   8300                       ST      Z,R16
     76          }
   \   00000012   9508                       RET
     77          
     78          

   \                                 In segment CODE, align 2, keep-with-next
     79          void wal_send485_char( void)
   \                     wal_send485_char:
     80          {
     81            UDR = uc_tx_chout;
   \   00000000   9100....                   LDS     R16,uc_tx_chout
   \   00000004   B90C                       OUT     0x0C,R16
     82            UCSRB &= ~(1<<TXB8);	// reset 9th bit
   \   00000006   9850                       CBI     0x0A,0x00
     83          }
   \   00000008   9508                       RET
     84          
     85          

   \                                 In segment CODE, align 2, keep-with-next
     86          void wal_tx_nrq(void )
   \                     wal_tx_nrq:
     87          {
     88          // Fixed attention request message format CMD:21, Data[4]:14
     89            uca_msgtx[0] = 0;
   \   00000000   E000                       LDI     R16,0
   \   00000002   9300....                   STS     uca_msgtx,R16
     90            uca_msgtx[1] = uc_comm_adid;
   \   00000006   9100....                   LDS     R16,uc_comm_adid
   \   0000000A   9300....                   STS     (uca_msgtx + 1),R16
     91            uca_msgtx[2] = 21;
   \   0000000E   E105                       LDI     R16,21
   \   00000010   9300....                   STS     (uca_msgtx + 2),R16
     92            uca_msgtx[3] = 0;
   \   00000014   E000                       LDI     R16,0
   \   00000016   9300....                   STS     (uca_msgtx + 3),R16
     93            uca_msgtx[4] = 14;
   \   0000001A   E00E                       LDI     R16,14
   \   0000001C   9300....                   STS     (uca_msgtx + 4),R16
     94          }
   \   00000020   9508                       RET
     95          
     96          

   \                                 In segment CODE, align 2, keep-with-next
     97          unsigned char wal_picnet_checkdata( void)
   \                     wal_picnet_checkdata:
     98          {
     99            if( (uca_msgrx[2] != 0x26) || ( uca_msgrx[3] != 0x26))
   \   00000000   9100....                   LDS     R16,(uca_msgrx + 2)
   \   00000004   3206                       CPI     R16,38
   \   00000006   F421                       BRNE    ??wal_picnet_checkdata_0
   \   00000008   9100....                   LDS     R16,(uca_msgrx + 3)
   \   0000000C   3206                       CPI     R16,38
   \   0000000E   F041                       BREQ    ??wal_picnet_checkdata_1
    100            {
    101              uca_msgtx[1] = '*';
   \                     ??wal_picnet_checkdata_0:
   \   00000010   E20A                       LDI     R16,42
   \   00000012   9300....                   STS     (uca_msgtx + 1),R16
    102              uca_msgtx[2] = 'I';
   \   00000016   E409                       LDI     R16,73
   \   00000018   9300....                   STS     (uca_msgtx + 2),R16
    103              return 1;
   \   0000001C   E001                       LDI     R16,1
   \   0000001E   9508                       RET
    104            }
    105            return 0;
   \                     ??wal_picnet_checkdata_1:
   \   00000020   E000                       LDI     R16,0
   \   00000022   9508                       RET
    106          }
    107          
    108          
    109          

   \                                 In segment CODE, align 2, keep-with-next
    110          void wal_picnet_motor( void)
   \                     wal_picnet_motor:
    111          {
   \   00000000   93BA                       ST      -Y,R27
   \   00000002   93AA                       ST      -Y,R26
    112          
    113          uca_msgtx[0] = (uc_comm_adid + 0x30);	// from me...
   \   00000004   9100....                   LDS     R16,uc_comm_adid
   \   00000008   5D00                       SUBI    R16,208
   \   0000000A   9300....                   STS     uca_msgtx,R16
    114          uca_msgtx[1] = (uca_msgrx[1] & 0xDF);   // echo,but CAPS masking 0x20
   \   0000000E   9100....                   LDS     R16,(uca_msgrx + 1)
   \   00000012   7D0F                       ANDI    R16,0xDF
   \   00000014   9300....                   STS     (uca_msgtx + 1),R16
    115          uca_msgtx[2] = uca_msgrx[2];    		// if in doubt echo data..
   \   00000018   9100....                   LDS     R16,(uca_msgrx + 2)
   \   0000001C   9300....                   STS     (uca_msgtx + 2),R16
    116          uca_msgtx[3] = uca_msgrx[3];    		// ..
   \   00000020   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000024   9300....                   STS     (uca_msgtx + 3),R16
    117          
    118          // response == ID, *, I, <x> if invalid
    119          // NB. confirm RXDHI == uca_msgtx[3]
    120          
    121          	switch( uca_msgrx[1])
   \   00000028   9100....                   LDS     R16,(uca_msgrx + 1)
   \   0000002C   5401                       SUBI    R16,65
   \   0000002E   F0A9                       BREQ    ??wal_picnet_motor_0
   \   00000030   950A                       DEC     R16
   \   00000032   F1B1                       BREQ    ??wal_picnet_motor_1
   \   00000034   5002                       SUBI    R16,2
   \   00000036   F409                       BRNE    $+2+2
   \   00000038   C040                       RJMP    ??wal_picnet_motor_2
   \   0000003A   5002                       SUBI    R16,2
   \   0000003C   F409                       BRNE    $+2+2
   \   0000003E   C058                       RJMP    ??wal_picnet_motor_3
   \   00000040   950A                       DEC     R16
   \   00000042   F409                       BRNE    $+2+2
   \   00000044   C062                       RJMP    ??wal_picnet_motor_4
   \   00000046   5009                       SUBI    R16,9
   \   00000048   F409                       BRNE    $+2+2
   \   0000004A   C101                       RJMP    ??wal_picnet_motor_5
   \   0000004C   5003                       SUBI    R16,3
   \   0000004E   F409                       BRNE    $+2+2
   \   00000050   C120                       RJMP    ??wal_picnet_motor_6
   \   00000052   5003                       SUBI    R16,3
   \   00000054   F409                       BRNE    $+2+2
   \   00000056   C120                       RJMP    ??wal_picnet_motor_7
   \   00000058   C12C                       RJMP    ??wal_picnet_motor_8
    122          	{
    123          	case 'A':
    124          		// assign address: NB. only reply if trigger in
    125          		if( val_ip_trg == 0)
   \                     ??wal_picnet_motor_0:
   \   0000005A   9100....                   LDS     R16,val_ip_trg
   \   0000005E   2300                       TST     R16
   \   00000060   F4D9                       BRNE    ??wal_picnet_motor_9
    126          		{
    127          			if( uca_msgrx[3] == 0x1f)
   \   00000062   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000066   310F                       CPI     R16,31
   \   00000068   F481                       BRNE    ??wal_picnet_motor_10
    128          			{
    129          				uc_comm_adid = uca_msgrx[2] & 0x0F;
   \   0000006A   9100....                   LDS     R16,(uca_msgrx + 2)
   \   0000006E   700F                       ANDI    R16,0x0F
   \   00000070   9300....                   STS     uc_comm_adid,R16
    130          				wal_eetbl_write( WAL_EE_COMMID, uc_comm_adid);
   \   00000074   9110....                   LDS     R17,uc_comm_adid
   \   00000078   E001                       LDI     R16,1
   \   0000007A   ........                   CALL    wal_eetbl_write
    131          				uca_msgtx[0] = (uc_comm_adid + 0x30);	// from me...
   \   0000007E   9100....                   LDS     R16,uc_comm_adid
   \   00000082   5D00                       SUBI    R16,208
   \   00000084   9300....                   STS     uca_msgtx,R16
   \   00000088   C11E                       RJMP    ??wal_picnet_motor_11
    132          			}
    133          			else
    134          			{
    135          				uca_msgtx[1] = '*';
   \                     ??wal_picnet_motor_10:
   \   0000008A   E20A                       LDI     R16,42
   \   0000008C   9300....                   STS     (uca_msgtx + 1),R16
    136          				uca_msgtx[2] = 'I';
   \   00000090   E409                       LDI     R16,73
   \   00000092   9300....                   STS     (uca_msgtx + 2),R16
   \   00000096   C117                       RJMP    ??wal_picnet_motor_11
    137          			}
    138          		}
    139          		else
    140          		{
    141          			// ignore, no reply
    142          			uc_comm_noecho = 1;
   \                     ??wal_picnet_motor_9:
   \   00000098   E001                       LDI     R16,1
   \   0000009A   9300....                   STS     uc_comm_noecho,R16
   \   0000009E   C113                       RJMP    ??wal_picnet_motor_11
    143          		}
    144          		break;
    145          	case 'B':
    146          		// backward move (datahi-lo = 0x26)
    147          		if( wal_picnet_checkdata() == 0)
   \                     ??wal_picnet_motor_1:
   \   000000A0   ....                       RCALL   wal_picnet_checkdata
   \   000000A2   2300                       TST     R16
   \   000000A4   F009                       BREQ    $+2+2
   \   000000A6   C10F                       RJMP    ??wal_picnet_motor_11
    148          		{
    149          			// set motor
    150          			uc_axis_dir = 0;
   \   000000A8   E000                       LDI     R16,0
   \   000000AA   9300....                   STS     uc_axis_dir,R16
    151          			uc_axis_pwm = WAL_PWM_TEST;
   \   000000AE   EC00                       LDI     R16,192
   \   000000B0   9300....                   STS     uc_axis_pwm,R16
    152          			wal_motor_start();
   \   000000B4   ........                   CALL    wal_motor_start
   \   000000B8   C106                       RJMP    ??wal_picnet_motor_11
    153          		}
    154          		break;
    155          	case 'D':
    156          		// define trigger in-out
    157          		// NB. has to force pattern as per porta into RXDLO
    158          		// assign address: NB. only reply if trigger in
    159          		if( val_ip_trg == 0)
   \                     ??wal_picnet_motor_2:
   \   000000BA   9100....                   LDS     R16,val_ip_trg
   \   000000BE   2300                       TST     R16
   \   000000C0   F499                       BRNE    ??wal_picnet_motor_12
    160          		{
    161          			if( uca_msgrx[3] == 0x1f)
   \   000000C2   9100....                   LDS     R16,(uca_msgrx + 3)
   \   000000C6   310F                       CPI     R16,31
   \   000000C8   F441                       BRNE    ??wal_picnet_motor_13
    162          			{
    163          				if( uca_msgrx[2] == 1)
   \   000000CA   9100....                   LDS     R16,(uca_msgrx + 2)
   \   000000CE   3001                       CPI     R16,1
   \   000000D0   F411                       BRNE    ??wal_picnet_motor_14
    164          				{
    165          					// set trigger out (active low)
    166          					WAL_OP_TRO = 0;
   \   000000D2   98C3                       CBI     0x18,0x03
   \   000000D4   C0F8                       RJMP    ??wal_picnet_motor_11
    167          				}
    168          				else
    169          				{
    170          					WAL_OP_TRO = 1;
   \                     ??wal_picnet_motor_14:
   \   000000D6   9AC3                       SBI     0x18,0x03
   \   000000D8   C0F6                       RJMP    ??wal_picnet_motor_11
    171          				}
    172          			}
    173          			else
    174          			{
    175          				uca_msgtx[1] = '*';
   \                     ??wal_picnet_motor_13:
   \   000000DA   E20A                       LDI     R16,42
   \   000000DC   9300....                   STS     (uca_msgtx + 1),R16
    176          				uca_msgtx[2] = 'I';
   \   000000E0   E409                       LDI     R16,73
   \   000000E2   9300....                   STS     (uca_msgtx + 2),R16
   \   000000E6   C0EF                       RJMP    ??wal_picnet_motor_11
    177          			}
    178          		}
    179          		else
    180          		{
    181          			// ignore, no reply
    182          			uc_comm_noecho = 1;
   \                     ??wal_picnet_motor_12:
   \   000000E8   E001                       LDI     R16,1
   \   000000EA   9300....                   STS     uc_comm_noecho,R16
   \   000000EE   C0EB                       RJMP    ??wal_picnet_motor_11
    183          		}
    184          		break;
    185          	case 'F':
    186          		// forward move (datahi-lo = 0x26)
    187          		if( wal_picnet_checkdata() == 0)
   \                     ??wal_picnet_motor_3:
   \   000000F0   ....                       RCALL   wal_picnet_checkdata
   \   000000F2   2300                       TST     R16
   \   000000F4   F009                       BREQ    $+2+2
   \   000000F6   C0E7                       RJMP    ??wal_picnet_motor_11
    188          		{
    189          			// set motor
    190          			uc_axis_dir = 1;
   \   000000F8   E001                       LDI     R16,1
   \   000000FA   9300....                   STS     uc_axis_dir,R16
    191          			uc_axis_pwm = WAL_PWM_TEST;
   \   000000FE   EC00                       LDI     R16,192
   \   00000100   9300....                   STS     uc_axis_pwm,R16
    192          			wal_motor_start();
   \   00000104   ........                   CALL    wal_motor_start
   \   00000108   C0DE                       RJMP    ??wal_picnet_motor_11
    193          		}
    194          		break;
    195          	case 'G':
    196          		// goto position
    197          		// respond with '*','U' if error condition:
    198          		// NB. error condition should include limit or home switch
    199          		if( wal_bsf_eeget( WAL_EE_ERROR) != 0)
   \                     ??wal_picnet_motor_4:
   \   0000010A   E005                       LDI     R16,5
   \   0000010C   ........                   CALL    wal_bsf_eeget
   \   00000110   2300                       TST     R16
   \   00000112   F061                       BREQ    ??wal_picnet_motor_15
    200          		{
    201          			uca_msgtx[1] = '*';
   \   00000114   E20A                       LDI     R16,42
   \   00000116   9300....                   STS     (uca_msgtx + 1),R16
    202          			uca_msgtx[2] = 'U';
   \   0000011A   E505                       LDI     R16,85
   \   0000011C   9300....                   STS     (uca_msgtx + 2),R16
    203          			uca_msgtx[3] = wal_bsf_eeget( WAL_EE_ERROR);
   \   00000120   E005                       LDI     R16,5
   \   00000122   ........                   CALL    wal_bsf_eeget
   \   00000126   9300....                   STS     (uca_msgtx + 3),R16
   \   0000012A   C0CD                       RJMP    ??wal_picnet_motor_11
    204          		}
    205          		else
    206          		{
    207          			// return '*','Q' if within +/- 3 units
    208          			// NB. convert from comms units (1/10th mm)	Lo-value + Hi-value
    209          			// to 'GEARR' units pulses WAL_GEAR_RATIO
    210          			// comms (Hi+Lo) * WAL_GEAR_RATIO == SET POINT
    211          			// difference == COUNTER (Hi+Lo) - SET POINT (Hi+Lo)
    212          			ui_axis_tmm = (uca_msgtx[3] << 8) + uca_msgtx[2];
   \                     ??wal_picnet_motor_15:
   \   0000012C   9130....                   LDS     R19,(uca_msgtx + 3)
   \   00000130   E020                       LDI     R18,0
   \   00000132   9100....                   LDS     R16,(uca_msgtx + 2)
   \   00000136   E010                       LDI     R17,0
   \   00000138   0F02                       ADD     R16,R18
   \   0000013A   1F13                       ADC     R17,R19
   \   0000013C   ....                       LDI     R30,LOW(ui_axis_tmm)
   \   0000013E   ....                       LDI     R31,(ui_axis_tmm) >> 8
   \   00000140   8300                       ST      Z,R16
   \   00000142   8311                       STD     Z+1,R17
    213          			ui_axis_set = ui_axis_tmm * 3;	// << 1 + 1
   \   00000144   ....                       LDI     R30,LOW(ui_axis_tmm)
   \   00000146   ....                       LDI     R31,(ui_axis_tmm) >> 8
   \   00000148   8140                       LD      R20,Z
   \   0000014A   8151                       LDD     R21,Z+1
   \   0000014C   E003                       LDI     R16,3
   \   0000014E   E010                       LDI     R17,0
   \   00000150   ........                   CALL    ?S_EC_MUL_L02
   \   00000154   ....                       LDI     R30,LOW(ui_axis_set)
   \   00000156   ....                       LDI     R31,(ui_axis_set) >> 8
   \   00000158   8300                       ST      Z,R16
   \   0000015A   8311                       STD     Z+1,R17
    214          			// set point (unsigned) if > 420mm then ignore (*U) 
    215          			if( ui_axis_set > WAL_MAX_SET_VALUE)
   \   0000015C   ....                       LDI     R30,LOW(ui_axis_set)
   \   0000015E   ....                       LDI     R31,(ui_axis_set) >> 8
   \   00000160   8100                       LD      R16,Z
   \   00000162   8111                       LDD     R17,Z+1
   \   00000164   3F0D                       CPI     R16,253
   \   00000166   E42E                       LDI     R18,78
   \   00000168   0712                       CPC     R17,R18
   \   0000016A   F050                       BRCS    ??wal_picnet_motor_16
    216          			{
    217          				uca_msgtx[1] = '*';
   \   0000016C   E20A                       LDI     R16,42
   \   0000016E   9300....                   STS     (uca_msgtx + 1),R16
    218          				uca_msgtx[2] = 'U';
   \   00000172   E505                       LDI     R16,85
   \   00000174   9300....                   STS     (uca_msgtx + 2),R16
    219          				uca_msgtx[3] = 0xFE;
   \   00000178   EF0E                       LDI     R16,254
   \   0000017A   9300....                   STS     (uca_msgtx + 3),R16
   \   0000017E   C0A3                       RJMP    ??wal_picnet_motor_11
    220          			}
    221          			else
    222          			{
    223          				if( ui_axis_pos > ui_axis_set)
   \                     ??wal_picnet_motor_16:
   \   00000180   ....                       LDI     R30,LOW(ui_axis_set)
   \   00000182   ....                       LDI     R31,(ui_axis_set) >> 8
   \   00000184   8100                       LD      R16,Z
   \   00000186   8111                       LDD     R17,Z+1
   \   00000188   ....                       LDI     R30,LOW(ui_axis_pos)
   \   0000018A   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   0000018C   8120                       LD      R18,Z
   \   0000018E   8131                       LDD     R19,Z+1
   \   00000190   1702                       CP      R16,R18
   \   00000192   0713                       CPC     R17,R19
   \   00000194   F570                       BRCC    ??wal_picnet_motor_17
    224          				{
    225          					ui_axis_diff = ui_axis_pos - ui_axis_set;
   \   00000196   ....                       LDI     R30,LOW(ui_axis_pos)
   \   00000198   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   0000019A   8100                       LD      R16,Z
   \   0000019C   8111                       LDD     R17,Z+1
   \   0000019E   ....                       LDI     R30,LOW(ui_axis_set)
   \   000001A0   ....                       LDI     R31,(ui_axis_set) >> 8
   \   000001A2   8120                       LD      R18,Z
   \   000001A4   8131                       LDD     R19,Z+1
   \   000001A6   1B02                       SUB     R16,R18
   \   000001A8   0B13                       SBC     R17,R19
   \   000001AA   ....                       LDI     R30,LOW(ui_axis_diff)
   \   000001AC   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   000001AE   8300                       ST      Z,R16
   \   000001B0   8311                       STD     Z+1,R17
    226          					// +'ve difference if < 4 then ignore
    227          					// also *U if difference too large (or causing -'ve value)
    228          					if( ui_axis_diff < 4)
   \   000001B2   ....                       LDI     R26,LOW(ui_axis_diff)
   \   000001B4   ....                       LDI     R27,(ui_axis_diff) >> 8
   \   000001B6   91ED                       LD      R30,X+
   \   000001B8   91FC                       LD      R31,X
   \   000001BA   9734                       SBIW    R31 : R30,4
   \   000001BC   F438                       BRCC    ??wal_picnet_motor_18
    229          					{
    230          						// ignore small difference
    231          						uca_msgtx[1] = '*';
   \   000001BE   E20A                       LDI     R16,42
   \   000001C0   9300....                   STS     (uca_msgtx + 1),R16
    232          						uca_msgtx[2] = 'Q';
   \   000001C4   E501                       LDI     R16,81
   \   000001C6   9300....                   STS     (uca_msgtx + 2),R16
   \   000001CA   C07D                       RJMP    ??wal_picnet_motor_11
    233          					}
    234          					else
    235          					{
    236          						// move forward (use sequence E_AxisMove)
    237          						// reply with difference in data lo-hi
    238          
    239          						if( SEQ_AddEvent( E_AxisMove) != UCC_OK )
   \                     ??wal_picnet_motor_18:
   \   000001CC   E006                       LDI     R16,6
   \   000001CE   ........                   CALL    SEQ_AddEvent
   \   000001D2   2300                       TST     R16
   \   000001D4   F011                       BREQ    ??wal_picnet_motor_19
    240          						{
    241          							vss_seq_error();
   \   000001D6   ........                   CALL    vss_seq_error
    242          						}
    243          
    244          						// uc_axis_dir = 1;
    245          						// uc_axis_pwm = WAL_PWM_STEPA;	// begin ramp up
    246          						// wal_motor_start();
    247          						uca_msgtx[2] = (unsigned char) (ui_axis_diff & 0x00FF);
   \                     ??wal_picnet_motor_19:
   \   000001DA   ....                       LDI     R30,LOW(ui_axis_diff)
   \   000001DC   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   000001DE   8100                       LD      R16,Z
   \   000001E0   9300....                   STS     (uca_msgtx + 2),R16
    248          						uca_msgtx[3] = (unsigned char) (ui_axis_diff >> 8);
   \   000001E4   ....                       LDI     R30,LOW(ui_axis_diff)
   \   000001E6   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   000001E8   8111                       LDD     R17,Z+1
   \   000001EA   2F01                       MOV     R16,R17
   \   000001EC   9300....                   STS     (uca_msgtx + 3),R16
   \   000001F0   C06A                       RJMP    ??wal_picnet_motor_11
    249          					}
    250          				}
    251          				else
    252          				{
    253          					ui_axis_diff = ui_axis_set - ui_axis_pos;
   \                     ??wal_picnet_motor_17:
   \   000001F2   ....                       LDI     R30,LOW(ui_axis_set)
   \   000001F4   ....                       LDI     R31,(ui_axis_set) >> 8
   \   000001F6   8100                       LD      R16,Z
   \   000001F8   8111                       LDD     R17,Z+1
   \   000001FA   ....                       LDI     R30,LOW(ui_axis_pos)
   \   000001FC   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   000001FE   8120                       LD      R18,Z
   \   00000200   8131                       LDD     R19,Z+1
   \   00000202   1B02                       SUB     R16,R18
   \   00000204   0B13                       SBC     R17,R19
   \   00000206   ....                       LDI     R30,LOW(ui_axis_diff)
   \   00000208   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   0000020A   8300                       ST      Z,R16
   \   0000020C   8311                       STD     Z+1,R17
    254          					// also *U if difference too large (or causing -'ve value)
    255          					if( ui_axis_diff < 4)
   \   0000020E   ....                       LDI     R26,LOW(ui_axis_diff)
   \   00000210   ....                       LDI     R27,(ui_axis_diff) >> 8
   \   00000212   91ED                       LD      R30,X+
   \   00000214   91FC                       LD      R31,X
   \   00000216   9734                       SBIW    R31 : R30,4
   \   00000218   F498                       BRCC    ??wal_picnet_motor_20
    256          					{
    257          						// negative difference so move in reverse
    258          						// decrease 'set point' for uni-directional motion,
    259          						// and set unidirection flag:
    260          
    261          						if( SEQ_AddEvent( E_AxisMove) != UCC_OK )
   \   0000021A   E006                       LDI     R16,6
   \   0000021C   ........                   CALL    SEQ_AddEvent
   \   00000220   2300                       TST     R16
   \   00000222   F011                       BREQ    ??wal_picnet_motor_21
    262          						{
    263          							vss_seq_error();
   \   00000224   ........                   CALL    vss_seq_error
    264          						}
    265          
    266          						// uc_axis_dir = 0;
    267          						// uc_axis_pwm = WAL_PWM_STEPA;	// begin ramp up
    268          						// wal_motor_start();
    269          						uca_msgtx[2] = (unsigned char) (ui_axis_diff & 0x00FF);
   \                     ??wal_picnet_motor_21:
   \   00000228   ....                       LDI     R30,LOW(ui_axis_diff)
   \   0000022A   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   0000022C   8100                       LD      R16,Z
   \   0000022E   9300....                   STS     (uca_msgtx + 2),R16
    270          						uca_msgtx[3] = (unsigned char) (ui_axis_diff >> 8);
   \   00000232   ....                       LDI     R30,LOW(ui_axis_diff)
   \   00000234   ....                       LDI     R31,(ui_axis_diff) >> 8
   \   00000236   8111                       LDD     R17,Z+1
   \   00000238   2F01                       MOV     R16,R17
   \   0000023A   9300....                   STS     (uca_msgtx + 3),R16
   \   0000023E   C043                       RJMP    ??wal_picnet_motor_11
    271          					}
    272          					else
    273          					{
    274          						// ignore small difference
    275          						uca_msgtx[1] = '*';
   \                     ??wal_picnet_motor_20:
   \   00000240   E20A                       LDI     R16,42
   \   00000242   9300....                   STS     (uca_msgtx + 1),R16
    276          						uca_msgtx[2] = 'Q';
   \   00000246   E501                       LDI     R16,81
   \   00000248   9300....                   STS     (uca_msgtx + 2),R16
   \   0000024C   C03C                       RJMP    ??wal_picnet_motor_11
    277          					}
    278          				}
    279          			}
    280          		}
    281          		break;
    282          	case 'P':
    283          		// position: reply 'C'+ count if moving; 'P' + position if stationery
    284          		// NB. check order of data-hi, data-lo
    285          		if( uc_axis_vss == 0)
   \                     ??wal_picnet_motor_5:
   \   0000024E   9100....                   LDS     R16,uc_axis_vss
   \   00000252   2300                       TST     R16
   \   00000254   F479                       BRNE    ??wal_picnet_motor_22
    286          		{
    287          			// idle, reply 'P' (set point ui_axis_set)
    288          			uca_msgtx[1] = 'P';
   \   00000256   E500                       LDI     R16,80
   \   00000258   9300....                   STS     (uca_msgtx + 1),R16
    289          			uca_msgtx[2] = (unsigned char) (ui_axis_set & 0x00FF);
   \   0000025C   ....                       LDI     R30,LOW(ui_axis_set)
   \   0000025E   ....                       LDI     R31,(ui_axis_set) >> 8
   \   00000260   8100                       LD      R16,Z
   \   00000262   9300....                   STS     (uca_msgtx + 2),R16
    290          			uca_msgtx[3] = (unsigned char) (ui_axis_set >> 8);
   \   00000266   ....                       LDI     R30,LOW(ui_axis_set)
   \   00000268   ....                       LDI     R31,(ui_axis_set) >> 8
   \   0000026A   8111                       LDD     R17,Z+1
   \   0000026C   2F01                       MOV     R16,R17
   \   0000026E   9300....                   STS     (uca_msgtx + 3),R16
   \   00000272   C029                       RJMP    ??wal_picnet_motor_11
    291          		}
    292          		else
    293          		{
    294          			// axis active, reply 'C' (current position ui_axis_pos)
    295          			uca_msgtx[1] = 'C';
   \                     ??wal_picnet_motor_22:
   \   00000274   E403                       LDI     R16,67
   \   00000276   9300....                   STS     (uca_msgtx + 1),R16
    296          			uca_msgtx[2] = (unsigned char) (ui_axis_pos & 0x00FF);
   \   0000027A   ....                       LDI     R30,LOW(ui_axis_pos)
   \   0000027C   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   0000027E   8100                       LD      R16,Z
   \   00000280   9300....                   STS     (uca_msgtx + 2),R16
    297          			uca_msgtx[3] = (unsigned char) (ui_axis_pos >> 8);
   \   00000284   ....                       LDI     R30,LOW(ui_axis_pos)
   \   00000286   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   00000288   8111                       LDD     R17,Z+1
   \   0000028A   2F01                       MOV     R16,R17
   \   0000028C   9300....                   STS     (uca_msgtx + 3),R16
   \   00000290   C01A                       RJMP    ??wal_picnet_motor_11
    298          		}
    299          		break;
    300          	case 'S':
    301          		// stop
    302          		wal_motor_stop();
   \                     ??wal_picnet_motor_6:
   \   00000292   ........                   CALL    wal_motor_stop
   \   00000296   C017                       RJMP    ??wal_picnet_motor_11
    303          		break;
    304          	case 'V':
    305          		// version (datahi-lo = 0x26)
    306          		if( wal_picnet_checkdata() == 0)
   \                     ??wal_picnet_motor_7:
   \   00000298   ....                       RCALL   wal_picnet_checkdata
   \   0000029A   2300                       TST     R16
   \   0000029C   F4A1                       BRNE    ??wal_picnet_motor_11
    307          		{
    308          			// respond with version	WAL_PIC_VERSION
    309          			uca_msgtx[1] = 'I';
   \   0000029E   E409                       LDI     R16,73
   \   000002A0   9300....                   STS     (uca_msgtx + 1),R16
    310          			uca_msgtx[2] = 'V';
   \   000002A4   E506                       LDI     R16,86
   \   000002A6   9300....                   STS     (uca_msgtx + 2),R16
    311          			uca_msgtx[3] = WAL_PIC_VERSION;
   \   000002AA   E00F                       LDI     R16,15
   \   000002AC   9300....                   STS     (uca_msgtx + 3),R16
   \   000002B0   C00A                       RJMP    ??wal_picnet_motor_11
    312          		}
    313          		break;
    314          	default:
    315          		// send '*','I' response + 'command' in data[3]
    316          		uca_msgtx[1] = '*';
   \                     ??wal_picnet_motor_8:
   \   000002B2   E20A                       LDI     R16,42
   \   000002B4   9300....                   STS     (uca_msgtx + 1),R16
    317          		uca_msgtx[2] = 'I';
   \   000002B8   E409                       LDI     R16,73
   \   000002BA   9300....                   STS     (uca_msgtx + 2),R16
    318          		uca_msgtx[3] = uca_msgrx[1];
   \   000002BE   9100....                   LDS     R16,(uca_msgrx + 1)
   \   000002C2   9300....                   STS     (uca_msgtx + 3),R16
    319          	}
    320          
    321          }
   \                     ??wal_picnet_motor_11:
   \   000002C6   91A9                       LD      R26,Y+
   \   000002C8   91B9                       LD      R27,Y+
   \   000002CA   9508                       RET
    322          

   \                                 In segment CODE, align 2, keep-with-next
    323          void wal_do_command( void)
   \                     wal_do_command:
    324          {
    325          //rx3rx4 = (unsigned int) ((rx[3] << 8) + rx[4]);
    326          
    327          uca_msgtx[0] = uca_msgrx[1];    	// back to originator (0)
   \   00000000   9100....                   LDS     R16,(uca_msgrx + 1)
   \   00000004   9300....                   STS     uca_msgtx,R16
    328          uca_msgtx[1] = uc_comm_adid; 		// from me...
   \   00000008   9100....                   LDS     R16,uc_comm_adid
   \   0000000C   9300....                   STS     (uca_msgtx + 1),R16
    329          uca_msgtx[2] = uca_msgrx[2];    	// cmd always echo'd
   \   00000010   9100....                   LDS     R16,(uca_msgrx + 2)
   \   00000014   9300....                   STS     (uca_msgtx + 2),R16
    330          uca_msgtx[3] = uca_msgrx[3];    	// if in doubt echo data..
   \   00000018   9100....                   LDS     R16,(uca_msgrx + 3)
   \   0000001C   9300....                   STS     (uca_msgtx + 3),R16
    331          uca_msgtx[4] = uca_msgrx[4];    	// ..
   \   00000020   9100....                   LDS     R16,(uca_msgrx + 4)
   \   00000024   9300....                   STS     (uca_msgtx + 4),R16
    332          
    333          switch( uca_msgrx[2])
   \   00000028   9100....                   LDS     R16,(uca_msgrx + 2)
   \   0000002C   ....                       LDI     R30,LOW(`?<Jumptable for wal_do_command>_0`)
   \   0000002E   ....                       LDI     R31,(`?<Jumptable for wal_do_command>_0`) >> 8
   \   00000030   ........                   JMP     ?CV_SWITCH_L06
    334              {
    335              case 0:    // get mode
    336                  uca_msgtx[4] = 0x04;
   \                     ??wal_do_command_0:
   \   00000034   E004                       LDI     R16,4
   \   00000036   9300....                   STS     (uca_msgtx + 4),R16
   \   0000003A   9508                       RET
    337                  break;
    338              case 1: 
    339              	// set variable (directly)
    340                  switch( uca_msgrx[3])
   \                     ??wal_do_command_1:
   \   0000003C   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000040   5000                       SUBI    R16,0
   \   00000042   F039                       BREQ    ??wal_do_command_2
   \   00000044   950A                       DEC     R16
   \   00000046   F049                       BREQ    ??wal_do_command_3
   \   00000048   950A                       DEC     R16
   \   0000004A   F059                       BREQ    ??wal_do_command_4
   \   0000004C   950A                       DEC     R16
   \   0000004E   F069                       BREQ    ??wal_do_command_5
   \   00000050   9508                       RET
    341                  {
    342                  case 0:
    343                          // direct set of PORTA
    344                          PORTA = uca_msgrx[4];
   \                     ??wal_do_command_2:
   \   00000052   9100....                   LDS     R16,(uca_msgrx + 4)
   \   00000056   BB0B                       OUT     0x1B,R16
   \   00000058   9508                       RET
    345                          break;
    346                  case 1:
    347                          // direct set of PORTB
    348                          PORTB = uca_msgrx[4];
   \                     ??wal_do_command_3:
   \   0000005A   9100....                   LDS     R16,(uca_msgrx + 4)
   \   0000005E   BB08                       OUT     0x18,R16
   \   00000060   9508                       RET
    349                          break;
    350                  case 2:
    351                          // direct set of PORTC
    352                          PORTC = uca_msgrx[4];
   \                     ??wal_do_command_4:
   \   00000062   9100....                   LDS     R16,(uca_msgrx + 4)
   \   00000066   BB05                       OUT     0x15,R16
   \   00000068   9508                       RET
    353                          break;
    354                  case 3:
    355                          // direct set of PORTD
    356                          PORTD = uca_msgrx[4];
   \                     ??wal_do_command_5:
   \   0000006A   9100....                   LDS     R16,(uca_msgrx + 4)
   \   0000006E   BB02                       OUT     0x12,R16
   \   00000070   9508                       RET
    357                          break;
    358                  }
    359                  break;
    360              case 2: 
    361              	// or register
    362                  switch( uca_msgrx[3])
   \                     ??wal_do_command_6:
   \   00000072   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000076   5000                       SUBI    R16,0
   \   00000078   F039                       BREQ    ??wal_do_command_7
   \   0000007A   950A                       DEC     R16
   \   0000007C   F059                       BREQ    ??wal_do_command_8
   \   0000007E   950A                       DEC     R16
   \   00000080   F079                       BREQ    ??wal_do_command_9
   \   00000082   950A                       DEC     R16
   \   00000084   F099                       BREQ    ??wal_do_command_10
   \   00000086   9508                       RET
    363                  {
    364                  case 0:
    365                          // direct OR of PORTA
    366                          PORTA = PINA | uca_msgrx[4];
   \                     ??wal_do_command_7:
   \   00000088   B309                       IN      R16,0x19
   \   0000008A   9110....                   LDS     R17,(uca_msgrx + 4)
   \   0000008E   2B10                       OR      R17,R16
   \   00000090   BB1B                       OUT     0x1B,R17
   \   00000092   9508                       RET
    367                          break;
    368                  case 1:
    369                          // direct OR of PORTB
    370                          PORTB = PINB | uca_msgrx[4];
   \                     ??wal_do_command_8:
   \   00000094   B306                       IN      R16,0x16
   \   00000096   9110....                   LDS     R17,(uca_msgrx + 4)
   \   0000009A   2B10                       OR      R17,R16
   \   0000009C   BB18                       OUT     0x18,R17
   \   0000009E   9508                       RET
    371                          break;
    372                  case 2:
    373                          // direct OR of PORTC
    374                          PORTC = PINC | uca_msgrx[4];
   \                     ??wal_do_command_9:
   \   000000A0   B303                       IN      R16,0x13
   \   000000A2   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000A6   2B10                       OR      R17,R16
   \   000000A8   BB15                       OUT     0x15,R17
   \   000000AA   9508                       RET
    375                          break;
    376                  case 3:
    377                          // direct OR of PORTD
    378                          PORTD = PIND | uca_msgrx[4];
   \                     ??wal_do_command_10:
   \   000000AC   B300                       IN      R16,0x10
   \   000000AE   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000B2   2B10                       OR      R17,R16
   \   000000B4   BB12                       OUT     0x12,R17
   \   000000B6   9508                       RET
    379                          break;
    380                  }
    381          		break;
    382              case 3: 
    383              	// and register
    384                  switch( uca_msgrx[3])
   \                     ??wal_do_command_11:
   \   000000B8   9100....                   LDS     R16,(uca_msgrx + 3)
   \   000000BC   5000                       SUBI    R16,0
   \   000000BE   F039                       BREQ    ??wal_do_command_12
   \   000000C0   950A                       DEC     R16
   \   000000C2   F059                       BREQ    ??wal_do_command_13
   \   000000C4   950A                       DEC     R16
   \   000000C6   F079                       BREQ    ??wal_do_command_14
   \   000000C8   950A                       DEC     R16
   \   000000CA   F099                       BREQ    ??wal_do_command_15
   \   000000CC   9508                       RET
    385                  {
    386                  case 0:
    387                          // direct AND of PORTA
    388                          PORTA = PINA & uca_msgrx[4];
   \                     ??wal_do_command_12:
   \   000000CE   B309                       IN      R16,0x19
   \   000000D0   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000D4   2310                       AND     R17,R16
   \   000000D6   BB1B                       OUT     0x1B,R17
   \   000000D8   9508                       RET
    389                          break;
    390                  case 1:
    391                          // direct AND of PORTB
    392                          PORTB = PINB & uca_msgrx[4];
   \                     ??wal_do_command_13:
   \   000000DA   B306                       IN      R16,0x16
   \   000000DC   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000E0   2310                       AND     R17,R16
   \   000000E2   BB18                       OUT     0x18,R17
   \   000000E4   9508                       RET
    393                          break;
    394                  case 2:
    395                          // direct AND of PORTC
    396                          PORTC = PINC & uca_msgrx[4];
   \                     ??wal_do_command_14:
   \   000000E6   B303                       IN      R16,0x13
   \   000000E8   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000EC   2310                       AND     R17,R16
   \   000000EE   BB15                       OUT     0x15,R17
   \   000000F0   9508                       RET
    397                          break;
    398                  case 3:
    399                          // direct AND of PORTD
    400                          PORTD = PIND & uca_msgrx[4];
   \                     ??wal_do_command_15:
   \   000000F2   B300                       IN      R16,0x10
   \   000000F4   9110....                   LDS     R17,(uca_msgrx + 4)
   \   000000F8   2310                       AND     R17,R16
   \   000000FA   BB12                       OUT     0x12,R17
   \   000000FC   9508                       RET
    401                          break;
    402                  }
    403                  break;
    404              case 5: // get register..
    405                  // 01NOV00 the only register directly accessed:
    406                  // should be $A3 (detector ref value)
    407                  switch( uca_msgrx[3])
   \                     ??wal_do_command_16:
   \   000000FE   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000102   5800                       SUBI    R16,128
   \   00000104   F0C9                       BREQ    ??wal_do_command_17
   \   00000106   5800                       SUBI    R16,128
   \   00000108   F039                       BREQ    ??wal_do_command_18
   \   0000010A   950A                       DEC     R16
   \   0000010C   F049                       BREQ    ??wal_do_command_19
   \   0000010E   950A                       DEC     R16
   \   00000110   F059                       BREQ    ??wal_do_command_20
   \   00000112   950A                       DEC     R16
   \   00000114   F069                       BREQ    ??wal_do_command_21
   \   00000116   9508                       RET
    408                  {
    409                  case 0:
    410                      // direct read of PORTA
    411                      uca_msgtx[4] = PINA;
   \                     ??wal_do_command_18:
   \   00000118   B309                       IN      R16,0x19
   \   0000011A   9300....                   STS     (uca_msgtx + 4),R16
   \   0000011E   9508                       RET
    412                      break;
    413                  case 1:
    414                      // direct read of PORTB
    415                      uca_msgtx[4] = PINB;
   \                     ??wal_do_command_19:
   \   00000120   B306                       IN      R16,0x16
   \   00000122   9300....                   STS     (uca_msgtx + 4),R16
   \   00000126   9508                       RET
    416                      break;
    417                  case 2:
    418                      // direct read of PORTC
    419                      uca_msgtx[4] = PINC;
   \                     ??wal_do_command_20:
   \   00000128   B303                       IN      R16,0x13
   \   0000012A   9300....                   STS     (uca_msgtx + 4),R16
   \   0000012E   9508                       RET
    420                      break;
    421                  case 3:
    422                      // direct read of PORTD
    423                      uca_msgtx[4] = PIND;
   \                     ??wal_do_command_21:
   \   00000130   B300                       IN      R16,0x10
   \   00000132   9300....                   STS     (uca_msgtx + 4),R16
   \   00000136   9508                       RET
    424                      break;
    425                  case 0x80:
    426                      //read from eeprom address rx4
    427          			__disable_interrupt();
   \                     ??wal_do_command_17:
   \   00000138   94F8                       CLI
    428                      uca_msgtx[3] = wal_bsf_eeget(uca_msgrx[4]);
   \   0000013A   9100....                   LDS     R16,(uca_msgrx + 4)
   \   0000013E   ........                   CALL    wal_bsf_eeget
   \   00000142   9300....                   STS     (uca_msgtx + 3),R16
    429          			__enable_interrupt();
   \   00000146   9478                       SEI
   \   00000148   9508                       RET
    430                      break;
    431                  }
    432                  break;
    433              case 14: // Status request:
    434                  uca_msgtx[3] = uc_axis_err;
   \                     ??wal_do_command_22:
   \   0000014A   9100....                   LDS     R16,uc_axis_err
   \   0000014E   9300....                   STS     (uca_msgtx + 3),R16
    435                  uca_msgtx[4] = uc_axis_vss;
   \   00000152   9100....                   LDS     R16,uc_axis_vss
   \   00000156   9300....                   STS     (uca_msgtx + 4),R16
   \   0000015A   9508                       RET
    436                  break; 
    437              case 15: // VERSION No REQUEST 
    438                  uca_msgtx[3] = def_major_ver;            // get_ee[x]...
   \                     ??wal_do_command_23:
   \   0000015C   E001                       LDI     R16,1
   \   0000015E   9300....                   STS     (uca_msgtx + 3),R16
    439                  uca_msgtx[4] = def_minor_ver;
   \   00000162   E008                       LDI     R16,8
   \   00000164   9300....                   STS     (uca_msgtx + 4),R16
   \   00000168   9508                       RET
    440                  break; 
    441              case 20:
    442                  // clear errors:
    443                  break;
    444              case 88:
    445                  // Get Max. allowable tacho limit: ui_axis_maxallow
    446                  uca_msgtx[3] = (unsigned char) (ui_axis_maxallow >> 8);
   \                     ??wal_do_command_24:
   \   0000016A   ....                       LDI     R30,LOW(ui_axis_maxallow)
   \   0000016C   ....                       LDI     R31,(ui_axis_maxallow) >> 8
   \   0000016E   8111                       LDD     R17,Z+1
   \   00000170   2F01                       MOV     R16,R17
   \   00000172   9300....                   STS     (uca_msgtx + 3),R16
    447                  uca_msgtx[4] = (unsigned char) (ui_axis_maxallow & 0x00FF);
   \   00000176   ....                       LDI     R30,LOW(ui_axis_maxallow)
   \   00000178   ....                       LDI     R31,(ui_axis_maxallow) >> 8
   \   0000017A   8100                       LD      R16,Z
   \   0000017C   9300....                   STS     (uca_msgtx + 4),R16
   \   00000180   9508                       RET
    448                  break;
    449              case 89:
    450                  // Set Max. allowable tacho limit: ui_axis_maxallow WAL_EE_MAXTHI, WAL_EE_MAXTLO
    451                  ui_axis_maxallow = (unsigned int) (uca_msgrx[3] << 8) + uca_msgrx[4];
   \                     ??wal_do_command_25:
   \   00000182   9130....                   LDS     R19,(uca_msgrx + 3)
   \   00000186   E020                       LDI     R18,0
   \   00000188   9100....                   LDS     R16,(uca_msgrx + 4)
   \   0000018C   E010                       LDI     R17,0
   \   0000018E   0F02                       ADD     R16,R18
   \   00000190   1F13                       ADC     R17,R19
   \   00000192   ....                       LDI     R30,LOW(ui_axis_maxallow)
   \   00000194   ....                       LDI     R31,(ui_axis_maxallow) >> 8
   \   00000196   8300                       ST      Z,R16
   \   00000198   8311                       STD     Z+1,R17
    452                  uc_axis_chi = uca_msgrx[3];
   \   0000019A   9100....                   LDS     R16,(uca_msgrx + 3)
   \   0000019E   9300....                   STS     uc_axis_chi,R16
    453                  uc_axis_clo = uca_msgrx[4];
   \   000001A2   9100....                   LDS     R16,(uca_msgrx + 4)
   \   000001A6   9300....                   STS     uc_axis_clo,R16
    454                  wal_eetbl_write( WAL_EE_MAXTHI, uc_axis_chi);
   \   000001AA   9110....                   LDS     R17,uc_axis_chi
   \   000001AE   E006                       LDI     R16,6
   \   000001B0   ........                   CALL    wal_eetbl_write
    455                  wal_eetbl_write( WAL_EE_MAXTLO, uc_axis_clo);
   \   000001B4   9110....                   LDS     R17,uc_axis_clo
   \   000001B8   E007                       LDI     R16,7
   \   000001BA   ........                   CALL    wal_eetbl_write
   \   000001BE   9508                       RET
    456                  break;
    457              case 90: // stop
    458                  // E_AxisStop()
    459                  wal_motor_stop();
   \                     ??wal_do_command_26:
   \   000001C0   ........                   CALL    wal_motor_stop
   \   000001C4   9508                       RET
    460                  break;
    461              case 91: // re-reference AddEvent
    462                  // V1.3 27JUN05: allow 'home' sequence if home switch active:
    463                  // if( val_ip_hom == 0){}
    464                  
    465                  uc_axis_vss = 4;
   \                     ??wal_do_command_27:
   \   000001C6   E004                       LDI     R16,4
   \   000001C8   9300....                   STS     uc_axis_vss,R16
    466                  
    467                  if( SEQ_AddEvent( E_AxisInvalid) != UCC_OK )
   \   000001CC   E004                       LDI     R16,4
   \   000001CE   ........                   CALL    SEQ_AddEvent
   \   000001D2   2300                       TST     R16
   \   000001D4   F409                       BRNE    $+2+2
   \   000001D6   C0C1                       RJMP    ??wal_do_command_28
    468                  {
    469                          vss_seq_error();
   \   000001D8   ........                   CALL    vss_seq_error
   \   000001DC   9508                       RET
    470                  }
    471                  break;
    472              case 92: // forwards or backward depending upon rx[3],rx[4]
    473                  if( val_ip_lim == 0) 
   \                     ??wal_do_command_29:
   \   000001DE   9100....                   LDS     R16,val_ip_lim
   \   000001E2   2300                       TST     R16
   \   000001E4   F009                       BREQ    $+2+2
   \   000001E6   C0B9                       RJMP    ??wal_do_command_28
    474                  {
    475                    uc_axis_dir = (uca_msgtx[3] == 1) ? 1: 0;
   \   000001E8   9100....                   LDS     R16,(uca_msgtx + 3)
   \   000001EC   3001                       CPI     R16,1
   \   000001EE   F411                       BRNE    ??wal_do_command_30
   \   000001F0   E001                       LDI     R16,1
   \   000001F2   C001                       RJMP    ??wal_do_command_31
   \                     ??wal_do_command_30:
   \   000001F4   E000                       LDI     R16,0
   \                     ??wal_do_command_31:
   \   000001F6   9300....                   STS     uc_axis_dir,R16
    476                    if( uca_msgtx[4] == 0)
   \   000001FA   9100....                   LDS     R16,(uca_msgtx + 4)
   \   000001FE   2300                       TST     R16
   \   00000200   F421                       BRNE    ??wal_do_command_32
    477                        uc_axis_pwm = WAL_PWM_TEST;
   \   00000202   EC00                       LDI     R16,192
   \   00000204   9300....                   STS     uc_axis_pwm,R16
   \   00000208   C004                       RJMP    ??wal_do_command_33
    478                    else
    479                        uc_axis_pwm = uca_msgtx[4];
   \                     ??wal_do_command_32:
   \   0000020A   9100....                   LDS     R16,(uca_msgtx + 4)
   \   0000020E   9300....                   STS     uc_axis_pwm,R16
    480                    wal_motor_start();
   \                     ??wal_do_command_33:
   \   00000212   ........                   CALL    wal_motor_start
   \   00000216   9508                       RET
    481                  }
    482                  break;
    483              case 93: // position
    484                  // position: reply 'C'+ count if moving; 'P' + position if stationery
    485                  // command must match in high speed comms (NB. data hi-lo swapped )
    486                  // therefore no differentiation of ui_axis_set or ui_axis_pos
    487                  // if( uc_axis_vss == 0) 
    488                  // need to convert ui_axis_pos -> 0.1mm units using conversion *5 /4
    489                  // ui_axis_postx = ui_axis_pos * 5/4 (ui_axis_conv, ui_axis_tacho)
    490                  
    491                  // ui_axis_tacho = ui_axis_pos >> 1;      // divide by 2
    492                  // store 'carry' flag
    493                  // uc_carrybit = WAL_CARRY_BIT ? 3: 0;
    494                  // ui_axis_mult = ui_axis_tacho * 5;     // mult. by 5
    495                  // if( uc_carrybit)
    496                  // {
    497                  //  ui_axis_mult += 3;
    498                  // }
    499                  // ui_axis_conv = ui_axis_mult >> 1;
    500                  // uca_msgtx[3] = (unsigned char) (ui_axis_conv >> 8);
    501                  // uca_msgtx[4] = (unsigned char) (ui_axis_conv & 0x00FF);
    502                  
    503                  // V1.8 27JAN06: give set point if moving...
    504                  if( uc_motoron)
   \                     ??wal_do_command_34:
   \   00000218   9100....                   LDS     R16,uc_motoron
   \   0000021C   2300                       TST     R16
   \   0000021E   F061                       BREQ    ??wal_do_command_35
    505                  {
    506                    uca_msgtx[3] = (unsigned char) (ui_axis_pos >> 8);
   \   00000220   ....                       LDI     R30,LOW(ui_axis_pos)
   \   00000222   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   00000224   8111                       LDD     R17,Z+1
   \   00000226   2F01                       MOV     R16,R17
   \   00000228   9300....                   STS     (uca_msgtx + 3),R16
    507                    uca_msgtx[4] = (unsigned char) (ui_axis_pos & 0x00FF);
   \   0000022C   ....                       LDI     R30,LOW(ui_axis_pos)
   \   0000022E   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   00000230   8100                       LD      R16,Z
   \   00000232   9300....                   STS     (uca_msgtx + 4),R16
   \   00000236   9508                       RET
    508                  }
    509                  else
    510                  {
    511                  
    512                    // V1.3 work in tacho units only
    513                    uca_msgtx[3] = (unsigned char) (ui_axis_pos >> 8);
   \                     ??wal_do_command_35:
   \   00000238   ....                       LDI     R30,LOW(ui_axis_pos)
   \   0000023A   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   0000023C   8111                       LDD     R17,Z+1
   \   0000023E   2F01                       MOV     R16,R17
   \   00000240   9300....                   STS     (uca_msgtx + 3),R16
    514                    uca_msgtx[4] = (unsigned char) (ui_axis_pos & 0x00FF);
   \   00000244   ....                       LDI     R30,LOW(ui_axis_pos)
   \   00000246   ....                       LDI     R31,(ui_axis_pos) >> 8
   \   00000248   8100                       LD      R16,Z
   \   0000024A   9300....                   STS     (uca_msgtx + 4),R16
    515                    
    516                    // V1.7 16JAN06: if uni-directional movement in progress
    517                    // report 'set-point' to prevent 'goto'
    518                    if( uc_unitravel)
   \   0000024E   9100....                   LDS     R16,uc_unitravel
   \   00000252   2300                       TST     R16
   \   00000254   F409                       BRNE    $+2+2
   \   00000256   C081                       RJMP    ??wal_do_command_28
    519                    {
    520                      uca_msgtx[3] = (unsigned char) (ui_axis_uni >> 8);
   \   00000258   ....                       LDI     R30,LOW(ui_axis_uni)
   \   0000025A   ....                       LDI     R31,(ui_axis_uni) >> 8
   \   0000025C   8111                       LDD     R17,Z+1
   \   0000025E   2F01                       MOV     R16,R17
   \   00000260   9300....                   STS     (uca_msgtx + 3),R16
    521                      uca_msgtx[4] = (unsigned char) (ui_axis_uni & 0x00FF);
   \   00000264   ....                       LDI     R30,LOW(ui_axis_uni)
   \   00000266   ....                       LDI     R31,(ui_axis_uni) >> 8
   \   00000268   8100                       LD      R16,Z
   \   0000026A   9300....                   STS     (uca_msgtx + 4),R16
   \   0000026E   9508                       RET
    522                    }
    523                  }
    524                  
    525                  break;
    526              case 94: // goto
    527                  // i.e. set position, ui_axis_set = rx[3][4]
    528                  // value set in 0.1mm units: conversion to tachos (0.125mm) = 4/5
    529                  // method *2; +3; divide by 5; *2 = 0.125 (i.e. tacho units)
    530                  // use WAL_MAX_SET_HIBYTE to protect max. parameter
    531                  
    532                  // V1.3 27JUN05: ignore 'goto' if axis error flag set: (must reref)
    533                  // uc_axis_err = 0;
    534                          
    535                  // V1.8 27JAN06: ignore 'goto' if moving...
    536                  if( (uca_msgrx[3] <= WAL_MAX_SET_HIBYTE) && (uc_axis_err == 0) && (uc_motoron == 0))
   \                     ??wal_do_command_36:
   \   00000270   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000274   340F                       CPI     R16,79
   \   00000276   F008                       BRCS    $+2+2
   \   00000278   C070                       RJMP    ??wal_do_command_28
   \   0000027A   9100....                   LDS     R16,uc_axis_err
   \   0000027E   2300                       TST     R16
   \   00000280   F009                       BREQ    $+2+2
   \   00000282   C06B                       RJMP    ??wal_do_command_28
   \   00000284   9100....                   LDS     R16,uc_motoron
   \   00000288   2300                       TST     R16
   \   0000028A   F009                       BREQ    $+2+2
   \   0000028C   C066                       RJMP    ??wal_do_command_28
    537                  {
    538                    // i.e. position < MAX
    539                    if( (uca_msgrx[3] == 0) && (uca_msgrx[4] < WAL_MIN_SET_LOBYTE) )
   \   0000028E   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000292   2300                       TST     R16
   \   00000294   F429                       BRNE    ??wal_do_command_37
   \   00000296   9100....                   LDS     R16,(uca_msgrx + 4)
   \   0000029A   3004                       CPI     R16,4
   \   0000029C   F408                       BRCC    $+2+2
   \   0000029E   C05D                       RJMP    ??wal_do_command_28
    540                    {
    541                      // i.e. position < 0.5mm therefore invalid
    542                    }
    543                    else
    544                    {
    545                      // V1.3 work in tacho units only
    546                      ui_axis_setrx = (unsigned int) (uca_msgrx[3] << 8) + uca_msgrx[4];
   \                     ??wal_do_command_37:
   \   000002A0   9130....                   LDS     R19,(uca_msgrx + 3)
   \   000002A4   E020                       LDI     R18,0
   \   000002A6   9100....                   LDS     R16,(uca_msgrx + 4)
   \   000002AA   E010                       LDI     R17,0
   \   000002AC   0F02                       ADD     R16,R18
   \   000002AE   1F13                       ADC     R17,R19
   \   000002B0   ....                       LDI     R30,LOW(ui_axis_setrx)
   \   000002B2   ....                       LDI     R31,(ui_axis_setrx) >> 8
   \   000002B4   8300                       ST      Z,R16
   \   000002B6   8311                       STD     Z+1,R17
    547                      if( ui_axis_setrx < ui_axis_maxallow)
   \   000002B8   ....                       LDI     R30,LOW(ui_axis_setrx)
   \   000002BA   ....                       LDI     R31,(ui_axis_setrx) >> 8
   \   000002BC   8100                       LD      R16,Z
   \   000002BE   8111                       LDD     R17,Z+1
   \   000002C0   ....                       LDI     R30,LOW(ui_axis_maxallow)
   \   000002C2   ....                       LDI     R31,(ui_axis_maxallow) >> 8
   \   000002C4   8120                       LD      R18,Z
   \   000002C6   8131                       LDD     R19,Z+1
   \   000002C8   1702                       CP      R16,R18
   \   000002CA   0713                       CPC     R17,R19
   \   000002CC   F440                       BRCC    ??wal_do_command_38
    548                      {
    549                        ui_axis_set = ui_axis_setrx;
   \   000002CE   ....                       LDI     R30,LOW(ui_axis_setrx)
   \   000002D0   ....                       LDI     R31,(ui_axis_setrx) >> 8
   \   000002D2   8100                       LD      R16,Z
   \   000002D4   8111                       LDD     R17,Z+1
   \   000002D6   ....                       LDI     R30,LOW(ui_axis_set)
   \   000002D8   ....                       LDI     R31,(ui_axis_set) >> 8
   \   000002DA   8300                       ST      Z,R16
   \   000002DC   8311                       STD     Z+1,R17
    550                      }
    551                      
    552                      // new (valid) set point
    553                      // ui_axis_setrx = (unsigned int) (uca_msgrx[3] << 8) + uca_msgrx[4];
    554                      // need to convert to tacho units :: 4/5
    555                      // ui_axis_tacho = ui_axis_setrx << 1;
    556                      // ui_axis_tacho += 3;
    557                      // ui_axis_mult = ui_axis_tacho / 5;     // divide by 5
    558                      // ui_axis_conv = ui_axis_mult << 1;
    559                      // ui_axis_set = ui_axis_conv;
    560                      
    561                      // E_AxisMove (MoveToPosition); Entry = A_AxisCalcProfile, A_MotorMove
    562                      // if( ui_axis_set != ui_axis_pos)
    563                      
    564                      
    565                      if( !wal_pos_similar())
   \                     ??wal_do_command_38:
   \   000002DE   ........                   CALL    wal_pos_similar
   \   000002E2   2300                       TST     R16
   \   000002E4   F5D1                       BRNE    ??wal_do_command_28
    566                      {
    567                        if( SEQ_AddEvent( E_AxisMove) != UCC_OK )
   \   000002E6   E006                       LDI     R16,6
   \   000002E8   ........                   CALL    SEQ_AddEvent
   \   000002EC   2300                       TST     R16
   \   000002EE   F1A9                       BREQ    ??wal_do_command_28
    568                        {
    569                          vss_seq_error();
   \   000002F0   ........                   CALL    vss_seq_error
   \   000002F4   9508                       RET
    570                        }
    571                      }     // set != pos
    572                    }       // else  set pt > LOBYTE
    573                  }         // rx[3] < HIBYTE
    574                  break;
    575              case 95: // address
    576                  if( val_ip_sw1 == 1)
   \                     ??wal_do_command_39:
   \   000002F6   9100....                   LDS     R16,val_ip_sw1
   \   000002FA   3001                       CPI     R16,1
   \   000002FC   F4B9                       BRNE    ??wal_do_command_40
    577                  {
    578                      uc_comm_adid = uca_msgrx[4] & 0x3F;
   \   000002FE   9100....                   LDS     R16,(uca_msgrx + 4)
   \   00000302   730F                       ANDI    R16,0x3F
   \   00000304   9300....                   STS     uc_comm_adid,R16
    579                      wal_eetbl_write( WAL_EE_COMMID, uc_comm_adid);
   \   00000308   9110....                   LDS     R17,uc_comm_adid
   \   0000030C   E001                       LDI     R16,1
   \   0000030E   ........                   CALL    wal_eetbl_write
    580                      uca_msgtx[1] = uc_comm_adid;
   \   00000312   9100....                   LDS     R16,uc_comm_adid
   \   00000316   9300....                   STS     (uca_msgtx + 1),R16
    581                      uc_axis_err = 1;
   \   0000031A   E001                       LDI     R16,1
   \   0000031C   9300....                   STS     uc_axis_err,R16
    582                      wal_eetbl_write( WAL_EE_ERROR, uc_axis_err);
   \   00000320   9110....                   LDS     R17,uc_axis_err
   \   00000324   E005                       LDI     R16,5
   \   00000326   ........                   CALL    wal_eetbl_write
   \   0000032A   9508                       RET
    583                  }
    584                  else
    585                  {
    586                      // ignore, no reply
    587                      uc_comm_noecho = 1;
   \                     ??wal_do_command_40:
   \   0000032C   E001                       LDI     R16,1
   \   0000032E   9300....                   STS     uc_comm_noecho,R16
   \   00000332   9508                       RET
    588                  }
    589                  break;
    590              case 96: // trigger (respond input) + button status
    591                  break;
    592              case 97: // trigger (set output)
    593                  break;
    594              case 98: // status (moving, error)
    595                  break;
    596              case 99: // speed
    597                  uc_axis_pwm = uca_msgrx[4];
   \                     ??wal_do_command_41:
   \   00000334   9100....                   LDS     R16,(uca_msgrx + 4)
   \   00000338   9300....                   STS     uc_axis_pwm,R16
   \   0000033C   9508                       RET
    598                  break;
    599              case 100:
    600                  // write to eeprom:
    601                  __disable_interrupt();
   \                     ??wal_do_command_42:
   \   0000033E   94F8                       CLI
    602                  wal_eetbl_write( uca_msgrx[3], uca_msgrx[4]);
   \   00000340   9110....                   LDS     R17,(uca_msgrx + 4)
   \   00000344   9100....                   LDS     R16,(uca_msgrx + 3)
   \   00000348   ........                   CALL    wal_eetbl_write
    603                  __enable_interrupt();
   \   0000034C   9478                       SEI
   \   0000034E   9508                       RET
    604                  break;
    605              default:
    606                  uca_msgtx[3] = uca_msgtx[4] = 0;
   \                     ??wal_do_command_43:
   \   00000350   E000                       LDI     R16,0
   \   00000352   9300....                   STS     (uca_msgtx + 4),R16
   \   00000356   9300....                   STS     (uca_msgtx + 3),R16
    607              }  
    608          } 
   \                     ??wal_do_command_28:
   \   0000035A   9508                       RET

   \                                 In segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for wal_do_command>_0`:
   \   00000000   00                         DB      0
   \   00000001   01                         DB      1
   \   00000002   ....                       DW      (??wal_do_command_43) /2
   \   00000004   ....                       DW      (??wal_do_command_0) /2
   \   00000006   01                         DB      0x1
   \   00000007   ....                       DW      (??wal_do_command_1) /2
   \   00000009   01                         DB      0x1
   \   0000000A   ....                       DW      (??wal_do_command_6) /2
   \   0000000C   01                         DB      0x1
   \   0000000D   ....                       DW      (??wal_do_command_11) /2
   \   0000000F   02                         DB      0x2
   \   00000010   ....                       DW      (??wal_do_command_16) /2
   \   00000012   09                         DB      0x9
   \   00000013   ....                       DW      (??wal_do_command_22) /2
   \   00000015   01                         DB      0x1
   \   00000016   ....                       DW      (??wal_do_command_23) /2
   \   00000018   05                         DB      0x5
   \   00000019   ....                       DW      (??wal_do_command_28) /2
   \   0000001B   44                         DB      0x44
   \   0000001C   ....                       DW      (??wal_do_command_24) /2
   \   0000001E   01                         DB      0x1
   \   0000001F   ....                       DW      (??wal_do_command_25) /2
   \   00000021   01                         DB      0x1
   \   00000022   ....                       DW      (??wal_do_command_26) /2
   \   00000024   01                         DB      0x1
   \   00000025   ....                       DW      (??wal_do_command_27) /2
   \   00000027   01                         DB      0x1
   \   00000028   ....                       DW      (??wal_do_command_29) /2
   \   0000002A   01                         DB      0x1
   \   0000002B   ....                       DW      (??wal_do_command_34) /2
   \   0000002D   01                         DB      0x1
   \   0000002E   ....                       DW      (??wal_do_command_36) /2
   \   00000030   01                         DB      0x1
   \   00000031   ....                       DW      (??wal_do_command_39) /2
   \   00000033   01                         DB      0x1
   \   00000034   ....                       DW      (??wal_do_command_28) /2
   \   00000036   01                         DB      0x1
   \   00000037   ....                       DW      (??wal_do_command_28) /2
   \   00000039   01                         DB      0x1
   \   0000003A   ....                       DW      (??wal_do_command_28) /2
   \   0000003C   01                         DB      0x1
   \   0000003D   ....                       DW      (??wal_do_command_41) /2
   \   0000003F   01                         DB      0x1
   \   00000040   ....                       DW      (??wal_do_command_42) /2
   \   00000042   FB                         DB      251
   \   00000043   00                         DB      0

   \                                 In segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_UBRRL
   \                     _A_UBRRL:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2a
   \   union <unnamed> volatile __io _A_UCSRB
   \                     _A_UCSRB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR
   \                     _A_UDR:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x32
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x33
   \   union <unnamed> volatile __io _A_PINC
   \                     _A_PINC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x35
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x36
   \   union <unnamed> volatile __io _A_PINB
   \                     _A_PINB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x38
   \   union <unnamed> volatile __io _A_PORTB
   \                     _A_PORTB:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x39
   \   union <unnamed> volatile __io _A_PINA
   \                     _A_PINA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x3b
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                              DS 1

   \                                 In segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_UBRRH
   \                     _A_UBRRH:
   \   00000000                              DS 1
    609          
    610          
    611          
    612          
    613          

   Maximum stack usage in bytes:

     Function                  CSTACK RSTACK
     --------                  ------ ------
     USART_Init_High               0      2
     USART_Init_Low                0      2
     wal_do_command                0      2
       -> wal_bsf_eeget            0      2
       -> wal_eetbl_write          0      2
       -> wal_eetbl_write          0      2
       -> wal_motor_stop           0      2
       -> SEQ_AddEvent             0      2
       -> vss_seq_error            0      2
       -> wal_motor_start          0      2
       -> wal_pos_similar          0      2
       -> SEQ_AddEvent             0      2
       -> vss_seq_error            0      2
       -> wal_eetbl_write          0      2
       -> wal_eetbl_write          0      2
       -> wal_eetbl_write          0      2
     wal_end_tx                    0      2
     wal_picnet_checkdata          0      2
     wal_picnet_motor              2      4
       -> wal_eetbl_write          2      2
       -> wal_picnet_checkdata     2      2
       -> wal_motor_start          2      2
       -> wal_picnet_checkdata     2      2
       -> wal_motor_start          2      2
       -> wal_bsf_eeget            2      2
       -> wal_bsf_eeget            2      2
       -> SEQ_AddEvent             2      2
       -> vss_seq_error            2      2
       -> SEQ_AddEvent             2      2
       -> vss_seq_error            2      2
       -> wal_motor_stop           2      2
       -> wal_picnet_checkdata     2      2
     wal_send485_char              0      2
     wal_start_tx                  0      2
     wal_tx_nrq                    0      2


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     USART_Init_High                  20
     USART_Init_Low                   16
     wal_start_tx                     30
     wal_end_tx                       20
     wal_send485_char                 10
     wal_tx_nrq                       34
     wal_picnet_checkdata             36
     wal_picnet_motor                716
     wal_do_command                  860
     ?<Jumptable for wal_do_command>_0
                                      68
     _A_UBRRL                          1
     _A_UCSRB                          1
     _A_UDR                            1
     _A_PIND                           1
     _A_PORTD                          1
     _A_PINC                           1
     _A_PORTC                          1
     _A_PINB                           1
     _A_PORTB                          1
     _A_PINA                           1
     _A_PORTA                          1
     _A_UBRRH                          1

 
    12 bytes in segment ABSOLUTE
 1 742 bytes in segment CODE
    68 bytes in segment SWITCH
 
 1 810 bytes of CODE memory
     0 bytes of DATA memory (+ 12 bytes shared)

Errors: none
Warnings: 3
